%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{PyGenAlgo}
\date{Nov 08, 2024}
\release{00.00.01}
\author{Michalis Vrettas, PhD}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{pygenalgo}
\label{\detokenize{modules:pygenalgo}}\label{\detokenize{modules::doc}}
\sphinxstepscope


\section{pygenalgo package}
\label{\detokenize{pygenalgo:pygenalgo-package}}\label{\detokenize{pygenalgo::doc}}

\subsection{Subpackages}
\label{\detokenize{pygenalgo:subpackages}}
\sphinxstepscope


\subsubsection{pygenalgo.engines package}
\label{\detokenize{pygenalgo.engines:pygenalgo-engines-package}}\label{\detokenize{pygenalgo.engines::doc}}

\paragraph{Submodules}
\label{\detokenize{pygenalgo.engines:submodules}}

\paragraph{pygenalgo.engines.auxiliary module}
\label{\detokenize{pygenalgo.engines:module-pygenalgo.engines.auxiliary}}\label{\detokenize{pygenalgo.engines:pygenalgo-engines-auxiliary-module}}\index{module@\spxentry{module}!pygenalgo.engines.auxiliary@\spxentry{pygenalgo.engines.auxiliary}}\index{pygenalgo.engines.auxiliary@\spxentry{pygenalgo.engines.auxiliary}!module@\spxentry{module}}\index{SubPopulation (class in pygenalgo.engines.auxiliary)@\spxentry{SubPopulation}\spxextra{class in pygenalgo.engines.auxiliary}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.auxiliary.SubPopulation}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.engines.auxiliary.}}\sphinxbfcode{\sphinxupquote{SubPopulation}}}{\sphinxparam{\DUrole{n}{pop\_id: int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{population: list = \textless{}factory\textgreater{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Auxiliary class container used in the IslandModelGA
to hold all the subpopulations (one on each island).
\index{id (pygenalgo.engines.auxiliary.SubPopulation property)@\spxentry{id}\spxextra{pygenalgo.engines.auxiliary.SubPopulation property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.auxiliary.SubPopulation.id}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{id}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }int}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor (getter) of the id parameter.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the id value.

\end{description}\end{quote}

\end{fulllineitems}

\index{pop\_id (pygenalgo.engines.auxiliary.SubPopulation attribute)@\spxentry{pop\_id}\spxextra{pygenalgo.engines.auxiliary.SubPopulation attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.auxiliary.SubPopulation.pop_id}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{pop\_id}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }int}}}
\pysigstopsignatures
\end{fulllineitems}

\index{population (pygenalgo.engines.auxiliary.SubPopulation attribute)@\spxentry{population}\spxextra{pygenalgo.engines.auxiliary.SubPopulation attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.auxiliary.SubPopulation.population}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{population}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }list}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{apply\_corrections() (in module pygenalgo.engines.auxiliary)@\spxentry{apply\_corrections()}\spxextra{in module pygenalgo.engines.auxiliary}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.auxiliary.apply_corrections}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygenalgo.engines.auxiliary.}}\sphinxbfcode{\sphinxupquote{apply\_corrections}}}{\sphinxparam{\DUrole{n}{input\_population}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{fit\_func}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Callable\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}}{{ $\rightarrow$ int}}
\pysigstopsignatures
\sphinxAtStartPar
Check the population  for invalid genes and correct them by applying directly
the random method. It is assumed that the random method of the Gene is always
returning a ‘valid’ value for the Gene. After that, we need to reevaluate the
chromosome to update its fitness.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{input\_population}} \textendash{} List(Chromosome) the population

\end{description}\end{quote}

\sphinxAtStartPar
we want to apply corrections (if applicable).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fit\_func}} \textendash{} callable fitness function.

\sphinxlineitem{Returns}
\sphinxAtStartPar
the total number of corrected genes in the population.

\end{description}\end{quote}

\end{fulllineitems}

\index{avg\_hamming\_dist() (in module pygenalgo.engines.auxiliary)@\spxentry{avg\_hamming\_dist()}\spxextra{in module pygenalgo.engines.auxiliary}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.auxiliary.avg_hamming_dist}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{pygenalgo.engines.auxiliary.}}\sphinxbfcode{\sphinxupquote{avg\_hamming\_dist}}}{\sphinxparam{\DUrole{n}{input\_population}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}\DUrole{p}{{]}}}}}{{ $\rightarrow$ float}}
\pysigstopsignatures
\sphinxAtStartPar
Computes the average Hamming distance of a population. We use
this to measure the similarity in the population of chromosomes.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{input\_population}} \textendash{} List(Chromosome) the population we want

\end{description}\end{quote}

\sphinxAtStartPar
to compute the average Hamming distance.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
(float) the total number of differences, in the genes,

\end{description}\end{quote}

\sphinxAtStartPar
divided by the total number of genes compared.

\end{fulllineitems}



\paragraph{pygenalgo.engines.generic\_ga module}
\label{\detokenize{pygenalgo.engines:module-pygenalgo.engines.generic_ga}}\label{\detokenize{pygenalgo.engines:pygenalgo-engines-generic-ga-module}}\index{module@\spxentry{module}!pygenalgo.engines.generic\_ga@\spxentry{pygenalgo.engines.generic\_ga}}\index{pygenalgo.engines.generic\_ga@\spxentry{pygenalgo.engines.generic\_ga}!module@\spxentry{module}}\index{GenericGA (class in pygenalgo.engines.generic\_ga)@\spxentry{GenericGA}\spxextra{class in pygenalgo.engines.generic\_ga}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.engines.generic\_ga.}}\sphinxbfcode{\sphinxupquote{GenericGA}}}{\sphinxparam{\DUrole{n}{initial\_pop}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{fit\_func}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Callable}}\sphinxparamcomma \sphinxparam{\DUrole{n}{select\_op}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.select_operator.SelectionOperator}]{\sphinxcrossref{SelectionOperator}}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mutate\_op}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.mutate_operator.MutationOperator}]{\sphinxcrossref{MutationOperator}}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{crossx\_op}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.crossover_operator.CrossoverOperator}]{\sphinxcrossref{CrossoverOperator}}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Generic GA class models the interface of a specific genetic algorithm model (or engine).
It provides the common variables and functionality that all GA models should share.
\end{quote}
\index{MAX\_CPUs (pygenalgo.engines.generic\_ga.GenericGA attribute)@\spxentry{MAX\_CPUs}\spxextra{pygenalgo.engines.generic\_ga.GenericGA attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA.MAX_CPUs}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{MAX\_CPUs}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }4}}}
\pysigstopsignatures
\end{fulllineitems}

\index{best\_chromosome() (pygenalgo.engines.generic\_ga.GenericGA method)@\spxentry{best\_chromosome()}\spxextra{pygenalgo.engines.generic\_ga.GenericGA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA.best_chromosome}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{best\_chromosome}}}{}{{ $\rightarrow$ {\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Auxiliary method that returns the chromosome with the
highest fitness value. Safeguarded with ignoring NaNs.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Return the chromosome with the highest fitness.

\end{description}\end{quote}

\end{fulllineitems}

\index{crossover\_mutate() (pygenalgo.engines.generic\_ga.GenericGA method)@\spxentry{crossover\_mutate()}\spxextra{pygenalgo.engines.generic\_ga.GenericGA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA.crossover_mutate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{crossover\_mutate}}}{\sphinxparam{\DUrole{n}{input\_population}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}\DUrole{p}{{]}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
This is an auxiliary method that combines the crossover and mutation
operations in one call. Since these operations happen in place the
‘input\_population’ will be modified directly.

\sphinxAtStartPar
This method should be called AFTER the selection of the parents that
have been selected for breeding.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{input\_population}} \textendash{} this is the population that we will apply

\end{description}\end{quote}

\sphinxAtStartPar
the two genetic operators.

\end{fulllineitems}

\index{crossover\_op (pygenalgo.engines.generic\_ga.GenericGA property)@\spxentry{crossover\_op}\spxextra{pygenalgo.engines.generic\_ga.GenericGA property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA.crossover_op}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{crossover\_op}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }{\hyperref[\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.crossover_operator.CrossoverOperator}]{\sphinxcrossref{CrossoverOperator}}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor method that returns the crossover operator reference.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the CrossoverOperator.

\end{description}\end{quote}

\end{fulllineitems}

\index{evaluate\_fitness() (pygenalgo.engines.generic\_ga.GenericGA method)@\spxentry{evaluate\_fitness()}\spxextra{pygenalgo.engines.generic\_ga.GenericGA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA.evaluate_fitness}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate\_fitness}}}{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method evaluates all the chromosomes’ of an input population
with a custom fitness function. After updating all the chromosomes
with their fitness, the method should return the average statistics
of mean and std of the population fitness.

\end{fulllineitems}

\index{fitness\_func (pygenalgo.engines.generic\_ga.GenericGA attribute)@\spxentry{fitness\_func}\spxextra{pygenalgo.engines.generic\_ga.GenericGA attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA.fitness_func}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{fitness\_func}}}
\pysigstopsignatures
\end{fulllineitems}

\index{individual\_fitness() (pygenalgo.engines.generic\_ga.GenericGA method)@\spxentry{individual\_fitness()}\spxextra{pygenalgo.engines.generic\_ga.GenericGA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA.individual_fitness}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{individual\_fitness}}}{\sphinxparam{\DUrole{n}{index}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}}{{ $\rightarrow$ float}}
\pysigstopsignatures
\sphinxAtStartPar
Get the fitness value of an individual member of the population.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{index}} \textendash{} Position of the individual in the population.

\sphinxlineitem{Returns}
\sphinxAtStartPar
The fitness value (float).

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate\_op (pygenalgo.engines.generic\_ga.GenericGA property)@\spxentry{mutate\_op}\spxextra{pygenalgo.engines.generic\_ga.GenericGA property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA.mutate_op}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{mutate\_op}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }{\hyperref[\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.mutate_operator.MutationOperator}]{\sphinxcrossref{MutationOperator}}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor method that returns the mutation operator reference.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the MutationOperator.

\end{description}\end{quote}

\end{fulllineitems}

\index{population (pygenalgo.engines.generic\_ga.GenericGA attribute)@\spxentry{population}\spxextra{pygenalgo.engines.generic\_ga.GenericGA attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA.population}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{population}}}
\pysigstopsignatures
\end{fulllineitems}

\index{population\_fitness() (pygenalgo.engines.generic\_ga.GenericGA method)@\spxentry{population\_fitness()}\spxextra{pygenalgo.engines.generic\_ga.GenericGA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA.population_fitness}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{population\_fitness}}}{}{{ $\rightarrow$ list\DUrole{p}{{[}}float\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Get the fitness values of all the population.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
A list with all the fitness values.

\end{description}\end{quote}

\end{fulllineitems}

\index{rng\_GA (pygenalgo.engines.generic\_ga.GenericGA attribute)@\spxentry{rng\_GA}\spxextra{pygenalgo.engines.generic\_ga.GenericGA attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA.rng_GA}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{rng\_GA}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }Generator(PCG64) at 0x7FB7AE9804A0}}}
\pysigstopsignatures
\end{fulllineitems}

\index{run() (pygenalgo.engines.generic\_ga.GenericGA method)@\spxentry{run()}\spxextra{pygenalgo.engines.generic\_ga.GenericGA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA.run}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\sphinxparam{\DUrole{o}{*}\DUrole{n}{args}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Main method of the Generic GA class, that implements the evolutionary routine.

\end{fulllineitems}

\index{select\_op (pygenalgo.engines.generic\_ga.GenericGA property)@\spxentry{select\_op}\spxextra{pygenalgo.engines.generic\_ga.GenericGA property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA.select_op}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{select\_op}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }{\hyperref[\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.select_operator.SelectionOperator}]{\sphinxcrossref{SelectionOperator}}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor method that returns the selection operator reference.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the SelectionOperator.

\end{description}\end{quote}

\end{fulllineitems}

\index{stats (pygenalgo.engines.generic\_ga.GenericGA property)@\spxentry{stats}\spxextra{pygenalgo.engines.generic\_ga.GenericGA property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA.stats}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{stats}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }dict}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor method that returns the ‘stats’ dictionary.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the dictionary with the statistics from the run.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{pygenalgo.engines.island\_model\_ga module}
\label{\detokenize{pygenalgo.engines:module-pygenalgo.engines.island_model_ga}}\label{\detokenize{pygenalgo.engines:pygenalgo-engines-island-model-ga-module}}\index{module@\spxentry{module}!pygenalgo.engines.island\_model\_ga@\spxentry{pygenalgo.engines.island\_model\_ga}}\index{pygenalgo.engines.island\_model\_ga@\spxentry{pygenalgo.engines.island\_model\_ga}!module@\spxentry{module}}\index{IslandModelGA (class in pygenalgo.engines.island\_model\_ga)@\spxentry{IslandModelGA}\spxextra{class in pygenalgo.engines.island\_model\_ga}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.island_model_ga.IslandModelGA}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.engines.island\_model\_ga.}}\sphinxbfcode{\sphinxupquote{IslandModelGA}}}{\sphinxparam{\DUrole{n}{num\_islands}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{migrate\_op}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.operators.migration:pygenalgo.operators.migration.clockwise_migration.ClockwiseMigration}]{\sphinxcrossref{ClockwiseMigration}}}\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GenericGA}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
In Island Model GA we run in parallel a number of “islands”, each one evolving its own
(sub)\sphinxhyphen{}population. Optionally we can allow “migration”, among the best individuals from
each island.
\end{quote}
\index{evaluate\_fitness() (pygenalgo.engines.island\_model\_ga.IslandModelGA method)@\spxentry{evaluate\_fitness()}\spxextra{pygenalgo.engines.island\_model\_ga.IslandModelGA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.island_model_ga.IslandModelGA.evaluate_fitness}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate\_fitness}}}{\sphinxparam{\DUrole{n}{in\_population: list{[}\textasciitilde{}pygenalgo.genome.chromosome.Chromosome{]}) \sphinxhyphen{}\textgreater{} (\textless{}class \textquotesingle{}float\textquotesingle{}\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{\textless{}class \textquotesingle{}float\textquotesingle{}\textgreater{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Evaluate all the chromosomes of the input population list with the
custom fitness  function. After updating all  the chromosomes with
their fitness, the method returns the average statistics mean/std.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{in\_population}} \textendash{} (list) The population of Chromosomes that we

\end{description}\end{quote}

\sphinxAtStartPar
want to evaluate their fitness.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
mean(fitness), std(fitness).

\end{description}\end{quote}

\end{fulllineitems}

\index{evolve\_population() (pygenalgo.engines.island\_model\_ga.IslandModelGA class method)@\spxentry{evolve\_population()}\spxextra{pygenalgo.engines.island\_model\_ga.IslandModelGA class method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.island_model_ga.IslandModelGA.evolve_population}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{classmethod\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{evolve\_population}}}{\sphinxparam{\DUrole{n}{island}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.engines:pygenalgo.engines.auxiliary.SubPopulation}]{\sphinxcrossref{SubPopulation}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{eval\_fitness}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Callable}}\sphinxparamcomma \sphinxparam{\DUrole{n}{epochs}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}}\sphinxparamcomma \sphinxparam{\DUrole{n}{crs\_op}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.crossover_operator.CrossoverOperator}]{\sphinxcrossref{CrossoverOperator}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{mut\_op}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.mutate_operator.MutationOperator}]{\sphinxcrossref{MutationOperator}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{sel\_op}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.select_operator.SelectionOperator}]{\sphinxcrossref{SelectionOperator}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{rnd\_gen}}\sphinxparamcomma \sphinxparam{\DUrole{n}{f\_tol}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{correction}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{elitism}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{True}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method is called to evolve each subpopulation independently.  It is defined as ‘classmethod’
because we need access to the fitness function of the object. The input parameters have identical
meaning with the ones from run().

\end{fulllineitems}

\index{migrate\_op (pygenalgo.engines.island\_model\_ga.IslandModelGA property)@\spxentry{migrate\_op}\spxextra{pygenalgo.engines.island\_model\_ga.IslandModelGA property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.island_model_ga.IslandModelGA.migrate_op}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{migrate\_op}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }{\hyperref[\detokenize{pygenalgo.operators.migration:pygenalgo.operators.migration.migration_operator.MigrationOperator}]{\sphinxcrossref{MigrationOperator}}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor method that returns the migration operator reference.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the MigrationOperator.

\end{description}\end{quote}

\end{fulllineitems}

\index{num\_islands (pygenalgo.engines.island\_model\_ga.IslandModelGA attribute)@\spxentry{num\_islands}\spxextra{pygenalgo.engines.island\_model\_ga.IslandModelGA attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.island_model_ga.IslandModelGA.num_islands}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{num\_islands}}}
\pysigstopsignatures
\end{fulllineitems}

\index{print\_migration\_stats() (pygenalgo.engines.island\_model\_ga.IslandModelGA method)@\spxentry{print\_migration\_stats()}\spxextra{pygenalgo.engines.island\_model\_ga.IslandModelGA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.island_model_ga.IslandModelGA.print_migration_stats}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{print\_migration\_stats}}}{}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Print the migration operators stats.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (pygenalgo.engines.island\_model\_ga.IslandModelGA method)@\spxentry{run()}\spxextra{pygenalgo.engines.island\_model\_ga.IslandModelGA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.island_model_ga.IslandModelGA.run}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\sphinxparam{\DUrole{n}{epochs}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1000}}\sphinxparamcomma \sphinxparam{\DUrole{n}{correction}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{elitism}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{f\_tol}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{allow\_migration}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{n\_periods}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{10}}\sphinxparamcomma \sphinxparam{\DUrole{n}{verbose}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Main method of the IslandModelGA class, that implements the evolutionary routine.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{epochs}} \textendash{} (int) maximum number of iterations in the evolution process.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{correction}} \textendash{} (bool) flag that if set to ‘True’ will check the validity of

\end{itemize}

\end{description}\end{quote}

\sphinxAtStartPar
the population (at the gene level) and attempt to correct the genome by calling
the random() method of the flawed gene.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{elitism}} \textendash{} (bool) flag that defines elitism. If ‘True’ then the chromosome

\end{description}\end{quote}

\sphinxAtStartPar
with the higher fitness will always be copied to the next generation (unaltered).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{f\_tol}} \textendash{} (float) tolerance in the difference between the average values of two

\end{description}\end{quote}

\sphinxAtStartPar
consecutive populations. It is used to determine the convergence of the population.
If this value is None (default) the algorithm will terminate using the epochs value.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{allow\_migration}} \textendash{} (bool) flag that if set to ‘True’ will allow the migration

\end{description}\end{quote}

\sphinxAtStartPar
of the best individuals among the different islands.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_periods}} \textendash{} (int) the number of times that we will break the main evolution

\end{description}\end{quote}

\sphinxAtStartPar
to allow for chromosomes to migrate. NB: This setting is active only when the option
allow\_migration == True. Otherwise, is ignored.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} (bool) if ‘True’ it will display periodically information about the

\end{description}\end{quote}

\sphinxAtStartPar
current stats of the subpopulations. NB: This setting is active only when the option
allow\_migration == True. Otherwise, is ignored.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{pygenalgo.engines.standard\_ga module}
\label{\detokenize{pygenalgo.engines:module-pygenalgo.engines.standard_ga}}\label{\detokenize{pygenalgo.engines:pygenalgo-engines-standard-ga-module}}\index{module@\spxentry{module}!pygenalgo.engines.standard\_ga@\spxentry{pygenalgo.engines.standard\_ga}}\index{pygenalgo.engines.standard\_ga@\spxentry{pygenalgo.engines.standard\_ga}!module@\spxentry{module}}\index{StandardGA (class in pygenalgo.engines.standard\_ga)@\spxentry{StandardGA}\spxextra{class in pygenalgo.engines.standard\_ga}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.standard_ga.StandardGA}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.engines.standard\_ga.}}\sphinxbfcode{\sphinxupquote{StandardGA}}}{\sphinxparam{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.engines:pygenalgo.engines.generic_ga.GenericGA}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GenericGA}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
StandardGA model provides a basic implementation of the “GenericGA”,
which at each iteration (epoch) replaces the whole population using
the genetic operators (crossover and mutation).
\end{quote}
\index{evaluate\_fitness() (pygenalgo.engines.standard\_ga.StandardGA method)@\spxentry{evaluate\_fitness()}\spxextra{pygenalgo.engines.standard\_ga.StandardGA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.standard_ga.StandardGA.evaluate_fitness}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{evaluate\_fitness}}}{\sphinxparam{\DUrole{n}{input\_population}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}\DUrole{p}{{]}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parallel}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}}{{ $\rightarrow$ list\DUrole{p}{{[}}float\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Evaluate all the chromosomes of the input list with the custom fitness function.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{input\_population}} \textendash{} (list) The population of Chromosomes that we want to

\end{description}\end{quote}

\sphinxAtStartPar
evaluate their fitness.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parallel}} \textendash{} (bool) Flag that enables parallel computation of the fitness function.

\sphinxlineitem{Returns}
\sphinxAtStartPar
a list of the fitness values.

\end{description}\end{quote}

\end{fulllineitems}

\index{fitness\_func (pygenalgo.engines.standard\_ga.StandardGA attribute)@\spxentry{fitness\_func}\spxextra{pygenalgo.engines.standard\_ga.StandardGA attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.standard_ga.StandardGA.fitness_func}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{fitness\_func}}}
\pysigstopsignatures
\end{fulllineitems}

\index{population (pygenalgo.engines.standard\_ga.StandardGA attribute)@\spxentry{population}\spxextra{pygenalgo.engines.standard\_ga.StandardGA attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.standard_ga.StandardGA.population}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{population}}}
\pysigstopsignatures
\end{fulllineitems}

\index{print\_operator\_stats() (pygenalgo.engines.standard\_ga.StandardGA method)@\spxentry{print\_operator\_stats()}\spxextra{pygenalgo.engines.standard\_ga.StandardGA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.standard_ga.StandardGA.print_operator_stats}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{print\_operator\_stats}}}{}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Print the genetic operators stats.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (pygenalgo.engines.standard\_ga.StandardGA method)@\spxentry{run()}\spxextra{pygenalgo.engines.standard\_ga.StandardGA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.standard_ga.StandardGA.run}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\sphinxparam{\DUrole{n}{epochs}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{100}}\sphinxparamcomma \sphinxparam{\DUrole{n}{elitism}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{True}}\sphinxparamcomma \sphinxparam{\DUrole{n}{correction}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{f\_tol}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }None}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parallel}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}\sphinxparamcomma \sphinxparam{\DUrole{n}{verbose}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{False}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Main method of the StandardGA class, that implements the evolutionary routine.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{epochs}} \textendash{} (int) maximum number of iterations in the evolution process.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{elitism}} \textendash{} (bool) flag that defines elitism. If ‘True’ then the chromosome

\end{itemize}

\end{description}\end{quote}

\sphinxAtStartPar
with the higher fitness will always be copied to the next generation (unaltered).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{correction}} \textendash{} (bool) flag that if set to ‘True’ will check the validity of

\end{description}\end{quote}

\sphinxAtStartPar
the population (at the gene level) and attempt to correct the genome by calling
the random() method of the flawed gene.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{f\_tol}} \textendash{} (float) tolerance in the difference between the average values of two

\end{description}\end{quote}

\sphinxAtStartPar
consecutive populations. It is used to determine the convergence of the population.
If this value is None (default) the algorithm will terminate using the epochs value.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parallel}} \textendash{} (bool) Flag that enables parallel computation of the fitness function.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{verbose}} \textendash{} (bool) if ‘True’ it will display periodically information about

\end{itemize}

\end{description}\end{quote}

\sphinxAtStartPar
the current average fitness and spread of the population.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_stats() (pygenalgo.engines.standard\_ga.StandardGA method)@\spxentry{update\_stats()}\spxextra{pygenalgo.engines.standard\_ga.StandardGA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.engines:pygenalgo.engines.standard_ga.StandardGA.update_stats}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update\_stats}}}{\sphinxparam{\DUrole{n}{fit\_list: list{[}float{]}) \sphinxhyphen{}\textgreater{} (\textless{}class \textquotesingle{}float\textquotesingle{}\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{\textless{}class \textquotesingle{}float\textquotesingle{}\textgreater{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Update the stats dictionary with the mean/std values of the
population fitness values.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fit\_list}} \textendash{} (float) mean fitness value of the population.

\sphinxlineitem{Returns}
\sphinxAtStartPar
the mean and std of the fitness values.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{pygenalgo.engines:module-pygenalgo.engines}}\label{\detokenize{pygenalgo.engines:module-contents}}\index{module@\spxentry{module}!pygenalgo.engines@\spxentry{pygenalgo.engines}}\index{pygenalgo.engines@\spxentry{pygenalgo.engines}!module@\spxentry{module}}
\sphinxstepscope


\subsubsection{pygenalgo.genome package}
\label{\detokenize{pygenalgo.genome:pygenalgo-genome-package}}\label{\detokenize{pygenalgo.genome::doc}}

\paragraph{Submodules}
\label{\detokenize{pygenalgo.genome:submodules}}

\paragraph{pygenalgo.genome.chromosome module}
\label{\detokenize{pygenalgo.genome:module-pygenalgo.genome.chromosome}}\label{\detokenize{pygenalgo.genome:pygenalgo-genome-chromosome-module}}\index{module@\spxentry{module}!pygenalgo.genome.chromosome@\spxentry{pygenalgo.genome.chromosome}}\index{pygenalgo.genome.chromosome@\spxentry{pygenalgo.genome.chromosome}!module@\spxentry{module}}\index{Chromosome (class in pygenalgo.genome.chromosome)@\spxentry{Chromosome}\spxextra{class in pygenalgo.genome.chromosome}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.genome.chromosome.}}\sphinxbfcode{\sphinxupquote{Chromosome}}}{\sphinxparam{\DUrole{n}{\_genome: list = \textless{}factory\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{\_fitness: float = 0.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{\_valid: bool = True}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Implements a dataclass for the Chromosome entity. This class is responsible
for holding the individual solution(s), of the optimization problem, during
the evolution process.
\end{quote}
\index{clone() (pygenalgo.genome.chromosome.Chromosome method)@\spxentry{clone()}\spxextra{pygenalgo.genome.chromosome.Chromosome method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome.clone}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clone}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Makes a duplicate of the self object.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
a “deep\sphinxhyphen{}copy” of the object.

\end{description}\end{quote}

\end{fulllineitems}

\index{fitness (pygenalgo.genome.chromosome.Chromosome property)@\spxentry{fitness}\spxextra{pygenalgo.genome.chromosome.Chromosome property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome.fitness}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{fitness}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }float}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor of the fitness value of the chromosome.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the fitness (float) of the genome.

\end{description}\end{quote}

\end{fulllineitems}

\index{genome (pygenalgo.genome.chromosome.Chromosome property)@\spxentry{genome}\spxextra{pygenalgo.genome.chromosome.Chromosome property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome.genome}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{genome}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.gene.Gene}]{\sphinxcrossref{Gene}}}\DUrole{p}{{]}}}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor of the genome list of the chromosome.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the list (of Genes) of the chromosome.

\end{description}\end{quote}

\end{fulllineitems}

\index{hamming\_distance() (pygenalgo.genome.chromosome.Chromosome method)@\spxentry{hamming\_distance()}\spxextra{pygenalgo.genome.chromosome.Chromosome method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome.hamming_distance}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{hamming\_distance}}}{\sphinxparam{\DUrole{n}{other}}}{{ $\rightarrow$ int}}
\pysigstopsignatures
\sphinxAtStartPar
Compute the “Hamming distance” of the “self” object with the
“other” chromosome. In practise it’s the number of positions
at which the corresponding genes are different.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{other}} \textendash{} (Chromosome) to compare the Hamming distance.

\sphinxlineitem{Returns}
\sphinxAtStartPar
(int) the distance between the two chromosomes.

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_genome\_valid() (pygenalgo.genome.chromosome.Chromosome method)@\spxentry{is\_genome\_valid()}\spxextra{pygenalgo.genome.chromosome.Chromosome method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome.is_genome_valid}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{is\_genome\_valid}}}{}{{ $\rightarrow$ bool}}
\pysigstopsignatures
\sphinxAtStartPar
Checks the validity of the whole chromosome, by
calling individually all genes is\_valid method.

\sphinxAtStartPar
In addition, it “double\sphinxhyphen{}checks” that all entries
in the genome are of type ‘Gene’.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
True if ALL genes are valid, else False.

\end{description}\end{quote}

\end{fulllineitems}

\index{valid (pygenalgo.genome.chromosome.Chromosome property)@\spxentry{valid}\spxextra{pygenalgo.genome.chromosome.Chromosome property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome.valid}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{valid}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }bool}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor (getter) of the validity parameter.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the valid value.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{pygenalgo.genome.gene module}
\label{\detokenize{pygenalgo.genome:module-pygenalgo.genome.gene}}\label{\detokenize{pygenalgo.genome:pygenalgo-genome-gene-module}}\index{module@\spxentry{module}!pygenalgo.genome.gene@\spxentry{pygenalgo.genome.gene}}\index{pygenalgo.genome.gene@\spxentry{pygenalgo.genome.gene}!module@\spxentry{module}}\index{Gene (class in pygenalgo.genome.gene)@\spxentry{Gene}\spxextra{class in pygenalgo.genome.gene}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.genome:pygenalgo.genome.gene.Gene}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.genome.gene.}}\sphinxbfcode{\sphinxupquote{Gene}}}{\sphinxparam{\DUrole{n}{datum}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Any}}\sphinxparamcomma \sphinxparam{\DUrole{n}{func}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{Callable}}\sphinxparamcomma \sphinxparam{\DUrole{n}{valid}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{bool}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{True}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
This is the main class that encodes the data of a single Gene in the chromosome.
The class encapsulates not only the data, but also the way that this gene can be
mutated using a random function. This Gene can be from a single ‘bit’ to a whole
image. This way provides us with flexibility to parameterize the chromosome with
different “kinds of genes” each one responsible for a specific function.
\end{quote}
\index{clone() (pygenalgo.genome.gene.Gene method)@\spxentry{clone()}\spxextra{pygenalgo.genome.gene.Gene method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.genome:pygenalgo.genome.gene.Gene.clone}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clone}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Makes a duplicate of the self object.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
a “deep\sphinxhyphen{}copy” of the object.

\end{description}\end{quote}

\end{fulllineitems}

\index{flip() (pygenalgo.genome.gene.Gene method)@\spxentry{flip()}\spxextra{pygenalgo.genome.gene.Gene method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.genome:pygenalgo.genome.gene.Gene.flip}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{flip}}}{}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
This method flips the value of the gene data. It is used only dy the
FlipMutator operator for problems where the chromosome is represented
by a list of bits.
\begin{enumerate}
\sphinxsetlistlabels{\roman}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
1 \sphinxhyphen{}\textgreater{} 0

\end{enumerate}
\begin{enumerate}
\sphinxsetlistlabels{\roman}{enumi}{enumii}{}{)}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
0 \sphinxhyphen{}\textgreater{} 1

\end{enumerate}
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{gaussian() (pygenalgo.genome.gene.Gene method)@\spxentry{gaussian()}\spxextra{pygenalgo.genome.gene.Gene method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.genome:pygenalgo.genome.gene.Gene.gaussian}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gaussian}}}{}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
This method adds a random value, drawn from a standard normal
distribution x \textasciitilde{} N(0,1) to the current gene data value. It is
used mostly from the GaussianMutator method.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_valid (pygenalgo.genome.gene.Gene property)@\spxentry{is\_valid}\spxextra{pygenalgo.genome.gene.Gene property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.genome:pygenalgo.genome.gene.Gene.is_valid}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{is\_valid}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }bool}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor (getter) of the validity parameter.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the valid value.

\end{description}\end{quote}

\end{fulllineitems}

\index{random() (pygenalgo.genome.gene.Gene method)@\spxentry{random()}\spxextra{pygenalgo.genome.gene.Gene method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.genome:pygenalgo.genome.gene.Gene.random}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{random}}}{}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
This method should be different for each type of Gene. It describes
how a specific type of Gene creates a random version of itself. The
main  idea is that inside the Chromosome, each Gene can represent a
very different concept of the  problem solution, so its Gene should
have its own way to perform random mutation.

\sphinxAtStartPar
This way by calling on the random() method, each Gene will know how
to mutate itself without breaking any rules/constraints.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{value (pygenalgo.genome.gene.Gene property)@\spxentry{value}\spxextra{pygenalgo.genome.gene.Gene property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.genome:pygenalgo.genome.gene.Gene.value}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{value}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }Any}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor (getter) of the data reference.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the datum value.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{pygenalgo.genome:module-pygenalgo.genome}}\label{\detokenize{pygenalgo.genome:module-contents}}\index{module@\spxentry{module}!pygenalgo.genome@\spxentry{pygenalgo.genome}}\index{pygenalgo.genome@\spxentry{pygenalgo.genome}!module@\spxentry{module}}
\sphinxstepscope


\subsubsection{pygenalgo.operators package}
\label{\detokenize{pygenalgo.operators:pygenalgo-operators-package}}\label{\detokenize{pygenalgo.operators::doc}}

\paragraph{Subpackages}
\label{\detokenize{pygenalgo.operators:subpackages}}
\sphinxstepscope


\subparagraph{pygenalgo.operators.crossover package}
\label{\detokenize{pygenalgo.operators.crossover:pygenalgo-operators-crossover-package}}\label{\detokenize{pygenalgo.operators.crossover::doc}}

\subparagraph{Submodules}
\label{\detokenize{pygenalgo.operators.crossover:submodules}}

\subparagraph{pygenalgo.operators.crossover.crossover\_operator module}
\label{\detokenize{pygenalgo.operators.crossover:module-pygenalgo.operators.crossover.crossover_operator}}\label{\detokenize{pygenalgo.operators.crossover:pygenalgo-operators-crossover-crossover-operator-module}}\index{module@\spxentry{module}!pygenalgo.operators.crossover.crossover\_operator@\spxentry{pygenalgo.operators.crossover.crossover\_operator}}\index{pygenalgo.operators.crossover.crossover\_operator@\spxentry{pygenalgo.operators.crossover.crossover\_operator}!module@\spxentry{module}}\index{CrossoverOperator (class in pygenalgo.operators.crossover.crossover\_operator)@\spxentry{CrossoverOperator}\spxextra{class in pygenalgo.operators.crossover.crossover\_operator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.crossover_operator.CrossoverOperator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.crossover.crossover\_operator.}}\sphinxbfcode{\sphinxupquote{CrossoverOperator}}}{\sphinxparam{\DUrole{n}{crossover\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators:pygenalgo.operators.genetic_operator.GeneticOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GeneticOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Provides the base class (interface) for a Crossover Operator.
\end{quote}
\index{crossover() (pygenalgo.operators.crossover.crossover\_operator.CrossoverOperator method)@\spxentry{crossover()}\spxextra{pygenalgo.operators.crossover.crossover\_operator.CrossoverOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.crossover_operator.CrossoverOperator.crossover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{crossover}}}{\sphinxparam{\DUrole{n}{parent1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parent2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Abstract method that “reminds” the user that if they want to
create a Crossover Class that inherits from here they should
implement a crossover method.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent1}} \textendash{} (Chromosome).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent2}} \textendash{} (Chromosome).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Nothing but raising an error.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.crossover.meta\_crossover module}
\label{\detokenize{pygenalgo.operators.crossover:module-pygenalgo.operators.crossover.meta_crossover}}\label{\detokenize{pygenalgo.operators.crossover:pygenalgo-operators-crossover-meta-crossover-module}}\index{module@\spxentry{module}!pygenalgo.operators.crossover.meta\_crossover@\spxentry{pygenalgo.operators.crossover.meta\_crossover}}\index{pygenalgo.operators.crossover.meta\_crossover@\spxentry{pygenalgo.operators.crossover.meta\_crossover}!module@\spxentry{module}}\index{MetaCrossover (class in pygenalgo.operators.crossover.meta\_crossover)@\spxentry{MetaCrossover}\spxextra{class in pygenalgo.operators.crossover.meta\_crossover}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.meta_crossover.MetaCrossover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.crossover.meta\_crossover.}}\sphinxbfcode{\sphinxupquote{MetaCrossover}}}{\sphinxparam{\DUrole{n}{crossover\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.9}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.crossover_operator.CrossoverOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CrossoverOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Meta\sphinxhyphen{}crossover, crosses the chromosomes by applying randomly
all other crossovers (one at a time), with equal probability.
\end{quote}
\index{all\_counters (pygenalgo.operators.crossover.meta\_crossover.MetaCrossover property)@\spxentry{all\_counters}\spxextra{pygenalgo.operators.crossover.meta\_crossover.MetaCrossover property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.meta_crossover.MetaCrossover.all_counters}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{all\_counters}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }dict}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor (getter) of the application counter from all the internal crossovers.
This is mostly to verify that everything is working as expected.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
a dictionary with the counter calls for all crossover methods.

\end{description}\end{quote}

\end{fulllineitems}

\index{crossover() (pygenalgo.operators.crossover.meta\_crossover.MetaCrossover method)@\spxentry{crossover()}\spxextra{pygenalgo.operators.crossover.meta\_crossover.MetaCrossover method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.meta_crossover.MetaCrossover.crossover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{crossover}}}{\sphinxparam{\DUrole{n}{parent1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parent2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Perform the crossover operation on the two input parent
chromosomes, by selecting randomly a predefined method.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent1}} \textendash{} (Chromosome).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent2}} \textendash{} (Chromosome).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
child1 and child2 (as Chromosomes).

\end{description}\end{quote}

\end{fulllineitems}

\index{reset\_counter() (pygenalgo.operators.crossover.meta\_crossover.MetaCrossover method)@\spxentry{reset\_counter()}\spxextra{pygenalgo.operators.crossover.meta\_crossover.MetaCrossover method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.meta_crossover.MetaCrossover.reset_counter}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset\_counter}}}{}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Sets ALL the counters to ‘zero’. We have to override the super().reset\_counter()
method, because we have to call explicitly the reset\_counter on all the internal
operators.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.crossover.mutli\_point\_crossover module}
\label{\detokenize{pygenalgo.operators.crossover:module-pygenalgo.operators.crossover.mutli_point_crossover}}\label{\detokenize{pygenalgo.operators.crossover:pygenalgo-operators-crossover-mutli-point-crossover-module}}\index{module@\spxentry{module}!pygenalgo.operators.crossover.mutli\_point\_crossover@\spxentry{pygenalgo.operators.crossover.mutli\_point\_crossover}}\index{pygenalgo.operators.crossover.mutli\_point\_crossover@\spxentry{pygenalgo.operators.crossover.mutli\_point\_crossover}!module@\spxentry{module}}\index{MultiPointCrossover (class in pygenalgo.operators.crossover.mutli\_point\_crossover)@\spxentry{MultiPointCrossover}\spxextra{class in pygenalgo.operators.crossover.mutli\_point\_crossover}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.mutli_point_crossover.MultiPointCrossover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.crossover.mutli\_point\_crossover.}}\sphinxbfcode{\sphinxupquote{MultiPointCrossover}}}{\sphinxparam{\DUrole{n}{crossover\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.9}}\sphinxparamcomma \sphinxparam{\DUrole{n}{num\_loci}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{2}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.crossover_operator.CrossoverOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CrossoverOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Multipoint crossover creates two children chromosomes (offsprings),
by taking two parent chromosomes and cutting them at randomly chosen,
sites (loci).

\sphinxAtStartPar
It produces faster mixing, compared with single\sphinxhyphen{}point crossover.
\end{quote}
\index{crossover() (pygenalgo.operators.crossover.mutli\_point\_crossover.MultiPointCrossover method)@\spxentry{crossover()}\spxextra{pygenalgo.operators.crossover.mutli\_point\_crossover.MultiPointCrossover method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.mutli_point_crossover.MultiPointCrossover.crossover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{crossover}}}{\sphinxparam{\DUrole{n}{parent1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parent2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Perform the crossover operation on the two input parent
chromosomes, using multiple cutting points (num\_loci).

\sphinxAtStartPar
NOTE: the number of loci is held in the ‘\_items’ variable.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent1}} \textendash{} (Chromosome).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent2}} \textendash{} (Chromosome).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
child1 and child2 (as Chromosomes).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.crossover.order\_crossover module}
\label{\detokenize{pygenalgo.operators.crossover:module-pygenalgo.operators.crossover.order_crossover}}\label{\detokenize{pygenalgo.operators.crossover:pygenalgo-operators-crossover-order-crossover-module}}\index{module@\spxentry{module}!pygenalgo.operators.crossover.order\_crossover@\spxentry{pygenalgo.operators.crossover.order\_crossover}}\index{pygenalgo.operators.crossover.order\_crossover@\spxentry{pygenalgo.operators.crossover.order\_crossover}!module@\spxentry{module}}\index{OrderCrossover (class in pygenalgo.operators.crossover.order\_crossover)@\spxentry{OrderCrossover}\spxextra{class in pygenalgo.operators.crossover.order\_crossover}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.order_crossover.OrderCrossover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.crossover.order\_crossover.}}\sphinxbfcode{\sphinxupquote{OrderCrossover}}}{\sphinxparam{\DUrole{n}{crossover\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.9}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.crossover_operator.CrossoverOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CrossoverOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Order crossover (OX1) creates two children chromosomes, by ensuring that the original
genome (from both parents) isn’t repeated, thus creating invalid offsprings.

\sphinxAtStartPar
It is used predominantly in combinatorial problems.
\end{quote}
\index{crossover() (pygenalgo.operators.crossover.order\_crossover.OrderCrossover method)@\spxentry{crossover()}\spxextra{pygenalgo.operators.crossover.order\_crossover.OrderCrossover method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.order_crossover.OrderCrossover.crossover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{crossover}}}{\sphinxparam{\DUrole{n}{parent1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parent2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Perform the crossover operation on the two input parent chromosomes.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent1}} \textendash{} (Chromosome).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent2}} \textendash{} (Chromosome).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
child1 and child2 (as Chromosomes).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.crossover.partially\_mapped\_crossover module}
\label{\detokenize{pygenalgo.operators.crossover:module-pygenalgo.operators.crossover.partially_mapped_crossover}}\label{\detokenize{pygenalgo.operators.crossover:pygenalgo-operators-crossover-partially-mapped-crossover-module}}\index{module@\spxentry{module}!pygenalgo.operators.crossover.partially\_mapped\_crossover@\spxentry{pygenalgo.operators.crossover.partially\_mapped\_crossover}}\index{pygenalgo.operators.crossover.partially\_mapped\_crossover@\spxentry{pygenalgo.operators.crossover.partially\_mapped\_crossover}!module@\spxentry{module}}\index{PartiallyMappedCrossover (class in pygenalgo.operators.crossover.partially\_mapped\_crossover)@\spxentry{PartiallyMappedCrossover}\spxextra{class in pygenalgo.operators.crossover.partially\_mapped\_crossover}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.partially_mapped_crossover.PartiallyMappedCrossover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.crossover.partially\_mapped\_crossover.}}\sphinxbfcode{\sphinxupquote{PartiallyMappedCrossover}}}{\sphinxparam{\DUrole{n}{crossover\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.9}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.crossover_operator.CrossoverOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CrossoverOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Partially Mapped Crossover (PMX) creates two children chromosomes, by ensuring that the
original genome (from both parents) isn’t repeated, thus creating invalid offsprings.

\sphinxAtStartPar
It is used predominantly in combinatorial problems.
\end{quote}
\index{crossover() (pygenalgo.operators.crossover.partially\_mapped\_crossover.PartiallyMappedCrossover method)@\spxentry{crossover()}\spxextra{pygenalgo.operators.crossover.partially\_mapped\_crossover.PartiallyMappedCrossover method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.partially_mapped_crossover.PartiallyMappedCrossover.crossover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{crossover}}}{\sphinxparam{\DUrole{n}{parent1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parent2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Perform the crossover operation on the two input parent chromosomes.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent1}} \textendash{} (Chromosome).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent2}} \textendash{} (Chromosome).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
child1 and child2 (as Chromosomes).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.crossover.position\_based\_crossover module}
\label{\detokenize{pygenalgo.operators.crossover:module-pygenalgo.operators.crossover.position_based_crossover}}\label{\detokenize{pygenalgo.operators.crossover:pygenalgo-operators-crossover-position-based-crossover-module}}\index{module@\spxentry{module}!pygenalgo.operators.crossover.position\_based\_crossover@\spxentry{pygenalgo.operators.crossover.position\_based\_crossover}}\index{pygenalgo.operators.crossover.position\_based\_crossover@\spxentry{pygenalgo.operators.crossover.position\_based\_crossover}!module@\spxentry{module}}\index{PositionBasedCrossover (class in pygenalgo.operators.crossover.position\_based\_crossover)@\spxentry{PositionBasedCrossover}\spxextra{class in pygenalgo.operators.crossover.position\_based\_crossover}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.position_based_crossover.PositionBasedCrossover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.crossover.position\_based\_crossover.}}\sphinxbfcode{\sphinxupquote{PositionBasedCrossover}}}{\sphinxparam{\DUrole{n}{crossover\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.9}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.crossover_operator.CrossoverOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CrossoverOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Position based crossover (POS) creates two children chromosomes, by ensuring that the
original genome (from both parents) isn’t repeated, thus creating invalid offsprings.

\sphinxAtStartPar
It is used predominantly in combinatorial problems.
\end{quote}
\index{crossover() (pygenalgo.operators.crossover.position\_based\_crossover.PositionBasedCrossover method)@\spxentry{crossover()}\spxextra{pygenalgo.operators.crossover.position\_based\_crossover.PositionBasedCrossover method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.position_based_crossover.PositionBasedCrossover.crossover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{crossover}}}{\sphinxparam{\DUrole{n}{parent1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parent2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Perform the crossover operation on the two input parent chromosomes.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent1}} \textendash{} (Chromosome).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent2}} \textendash{} (Chromosome).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
child1 and child2 (as Chromosomes).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.crossover.single\_point\_crossover module}
\label{\detokenize{pygenalgo.operators.crossover:module-pygenalgo.operators.crossover.single_point_crossover}}\label{\detokenize{pygenalgo.operators.crossover:pygenalgo-operators-crossover-single-point-crossover-module}}\index{module@\spxentry{module}!pygenalgo.operators.crossover.single\_point\_crossover@\spxentry{pygenalgo.operators.crossover.single\_point\_crossover}}\index{pygenalgo.operators.crossover.single\_point\_crossover@\spxentry{pygenalgo.operators.crossover.single\_point\_crossover}!module@\spxentry{module}}\index{SinglePointCrossover (class in pygenalgo.operators.crossover.single\_point\_crossover)@\spxentry{SinglePointCrossover}\spxextra{class in pygenalgo.operators.crossover.single\_point\_crossover}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.single_point_crossover.SinglePointCrossover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.crossover.single\_point\_crossover.}}\sphinxbfcode{\sphinxupquote{SinglePointCrossover}}}{\sphinxparam{\DUrole{n}{crossover\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.9}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.crossover_operator.CrossoverOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CrossoverOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Single\sphinxhyphen{}point crossover creates two children chromosomes (offsprings),
by taking two parent chromosomes and cutting them at some, randomly
chosen, site (locus).

\sphinxAtStartPar
It produces very slow mixing, compared with multipoint or uniform crossover.
\end{quote}
\index{crossover() (pygenalgo.operators.crossover.single\_point\_crossover.SinglePointCrossover method)@\spxentry{crossover()}\spxextra{pygenalgo.operators.crossover.single\_point\_crossover.SinglePointCrossover method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.single_point_crossover.SinglePointCrossover.crossover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{crossover}}}{\sphinxparam{\DUrole{n}{parent1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parent2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Perform the crossover operation on the two input parent chromosomes.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent1}} \textendash{} (Chromosome).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent2}} \textendash{} (Chromosome).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
child1 and child2 (as Chromosomes).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.crossover.uniform\_crossover module}
\label{\detokenize{pygenalgo.operators.crossover:module-pygenalgo.operators.crossover.uniform_crossover}}\label{\detokenize{pygenalgo.operators.crossover:pygenalgo-operators-crossover-uniform-crossover-module}}\index{module@\spxentry{module}!pygenalgo.operators.crossover.uniform\_crossover@\spxentry{pygenalgo.operators.crossover.uniform\_crossover}}\index{pygenalgo.operators.crossover.uniform\_crossover@\spxentry{pygenalgo.operators.crossover.uniform\_crossover}!module@\spxentry{module}}\index{UniformCrossover (class in pygenalgo.operators.crossover.uniform\_crossover)@\spxentry{UniformCrossover}\spxextra{class in pygenalgo.operators.crossover.uniform\_crossover}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.uniform_crossover.UniformCrossover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.crossover.uniform\_crossover.}}\sphinxbfcode{\sphinxupquote{UniformCrossover}}}{\sphinxparam{\DUrole{n}{crossover\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.9}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.crossover_operator.CrossoverOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CrossoverOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Uniform crossover creates two children chromosomes (offsprings),
by taking two parent chromosomes and swap their genes in every
other location.

\sphinxAtStartPar
It produces fast mixing, compared with single\sphinxhyphen{}point crossover.
\end{quote}
\index{crossover() (pygenalgo.operators.crossover.uniform\_crossover.UniformCrossover method)@\spxentry{crossover()}\spxextra{pygenalgo.operators.crossover.uniform\_crossover.UniformCrossover method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.crossover:pygenalgo.operators.crossover.uniform_crossover.UniformCrossover.crossover}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{crossover}}}{\sphinxparam{\DUrole{n}{parent1}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{parent2}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Perform the crossover operation on the two input parent chromosomes.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent1}} \textendash{} (Chromosome).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parent2}} \textendash{} (Chromosome).

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
child1 and child2 (as Chromosomes).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{Module contents}
\label{\detokenize{pygenalgo.operators.crossover:module-pygenalgo.operators.crossover}}\label{\detokenize{pygenalgo.operators.crossover:module-contents}}\index{module@\spxentry{module}!pygenalgo.operators.crossover@\spxentry{pygenalgo.operators.crossover}}\index{pygenalgo.operators.crossover@\spxentry{pygenalgo.operators.crossover}!module@\spxentry{module}}
\sphinxstepscope


\subparagraph{pygenalgo.operators.migration package}
\label{\detokenize{pygenalgo.operators.migration:pygenalgo-operators-migration-package}}\label{\detokenize{pygenalgo.operators.migration::doc}}

\subparagraph{Submodules}
\label{\detokenize{pygenalgo.operators.migration:submodules}}

\subparagraph{pygenalgo.operators.migration.clockwise\_migration module}
\label{\detokenize{pygenalgo.operators.migration:module-pygenalgo.operators.migration.clockwise_migration}}\label{\detokenize{pygenalgo.operators.migration:pygenalgo-operators-migration-clockwise-migration-module}}\index{module@\spxentry{module}!pygenalgo.operators.migration.clockwise\_migration@\spxentry{pygenalgo.operators.migration.clockwise\_migration}}\index{pygenalgo.operators.migration.clockwise\_migration@\spxentry{pygenalgo.operators.migration.clockwise\_migration}!module@\spxentry{module}}\index{ClockwiseMigration (class in pygenalgo.operators.migration.clockwise\_migration)@\spxentry{ClockwiseMigration}\spxextra{class in pygenalgo.operators.migration.clockwise\_migration}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.migration:pygenalgo.operators.migration.clockwise_migration.ClockwiseMigration}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.migration.clockwise\_migration.}}\sphinxbfcode{\sphinxupquote{ClockwiseMigration}}}{\sphinxparam{\DUrole{n}{migration\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.95}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.migration:pygenalgo.operators.migration.migration_operator.MigrationOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MigrationOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Clockwise Migration implements a “very basic” migration policy in which
each island migrates its best chromosome to the population on its right,
following a “clockwise” rotation movement.
\end{quote}
\index{migrate() (pygenalgo.operators.migration.clockwise\_migration.ClockwiseMigration method)@\spxentry{migrate()}\spxextra{pygenalgo.operators.migration.clockwise\_migration.ClockwiseMigration method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.migration:pygenalgo.operators.migration.clockwise_migration.ClockwiseMigration.migrate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{migrate}}}{\sphinxparam{\DUrole{n}{islands}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.engines:pygenalgo.engines.auxiliary.SubPopulation}]{\sphinxcrossref{SubPopulation}}}\DUrole{p}{{]}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Perform the migration operation on the list of SubPopulations.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{islands}} \textendash{} list{[}SubPopulation{]}.

\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.migration.meta\_migration module}
\label{\detokenize{pygenalgo.operators.migration:module-pygenalgo.operators.migration.meta_migration}}\label{\detokenize{pygenalgo.operators.migration:pygenalgo-operators-migration-meta-migration-module}}\index{module@\spxentry{module}!pygenalgo.operators.migration.meta\_migration@\spxentry{pygenalgo.operators.migration.meta\_migration}}\index{pygenalgo.operators.migration.meta\_migration@\spxentry{pygenalgo.operators.migration.meta\_migration}!module@\spxentry{module}}\index{MetaMigration (class in pygenalgo.operators.migration.meta\_migration)@\spxentry{MetaMigration}\spxextra{class in pygenalgo.operators.migration.meta\_migration}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.migration:pygenalgo.operators.migration.meta_migration.MetaMigration}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.migration.meta\_migration.}}\sphinxbfcode{\sphinxupquote{MetaMigration}}}{\sphinxparam{\DUrole{n}{migration\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.95}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.migration:pygenalgo.operators.migration.migration_operator.MigrationOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MigrationOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Meta\sphinxhyphen{}migrator, performs the migration between the subpopulations by applying
randomly all other migrators (one at a time), with equal probability.

\sphinxAtStartPar
NOTE: In the future the equal probabilities can be amended.
\end{quote}
\index{all\_counters (pygenalgo.operators.migration.meta\_migration.MetaMigration property)@\spxentry{all\_counters}\spxextra{pygenalgo.operators.migration.meta\_migration.MetaMigration property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.migration:pygenalgo.operators.migration.meta_migration.MetaMigration.all_counters}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{all\_counters}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }dict}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor (getter) of the application counter from all the internal migrators.
This is mostly to verify that everything is working as expected.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
a dictionary with the counter calls for all migrator methods.

\end{description}\end{quote}

\end{fulllineitems}

\index{migrate() (pygenalgo.operators.migration.meta\_migration.MetaMigration method)@\spxentry{migrate()}\spxextra{pygenalgo.operators.migration.meta\_migration.MetaMigration method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.migration:pygenalgo.operators.migration.meta_migration.MetaMigration.migrate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{migrate}}}{\sphinxparam{\DUrole{n}{islands}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.engines:pygenalgo.engines.auxiliary.SubPopulation}]{\sphinxcrossref{SubPopulation}}}\DUrole{p}{{]}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Perform the migration operation on the list of SubPopulations.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{islands}} \textendash{} list{[}SubPopulation{]}.

\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{reset\_counter() (pygenalgo.operators.migration.meta\_migration.MetaMigration method)@\spxentry{reset\_counter()}\spxextra{pygenalgo.operators.migration.meta\_migration.MetaMigration method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.migration:pygenalgo.operators.migration.meta_migration.MetaMigration.reset_counter}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset\_counter}}}{}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Sets ALL the counters to ‘zero’. We have to override the super().reset\_counter()
method, because we have to call explicitly the reset\_counter on all the internal
operators.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.migration.migration\_operator module}
\label{\detokenize{pygenalgo.operators.migration:module-pygenalgo.operators.migration.migration_operator}}\label{\detokenize{pygenalgo.operators.migration:pygenalgo-operators-migration-migration-operator-module}}\index{module@\spxentry{module}!pygenalgo.operators.migration.migration\_operator@\spxentry{pygenalgo.operators.migration.migration\_operator}}\index{pygenalgo.operators.migration.migration\_operator@\spxentry{pygenalgo.operators.migration.migration\_operator}!module@\spxentry{module}}\index{MigrationOperator (class in pygenalgo.operators.migration.migration\_operator)@\spxentry{MigrationOperator}\spxextra{class in pygenalgo.operators.migration.migration\_operator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.migration:pygenalgo.operators.migration.migration_operator.MigrationOperator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.migration.migration\_operator.}}\sphinxbfcode{\sphinxupquote{MigrationOperator}}}{\sphinxparam{\DUrole{n}{migration\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators:pygenalgo.operators.genetic_operator.GeneticOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GeneticOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Provides the base class (interface) for a Migration Operator.
\end{quote}
\index{migrate() (pygenalgo.operators.migration.migration\_operator.MigrationOperator method)@\spxentry{migrate()}\spxextra{pygenalgo.operators.migration.migration\_operator.MigrationOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.migration:pygenalgo.operators.migration.migration_operator.MigrationOperator.migrate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{migrate}}}{\sphinxparam{\DUrole{n}{islands}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.engines:pygenalgo.engines.auxiliary.SubPopulation}]{\sphinxcrossref{SubPopulation}}}\DUrole{p}{{]}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Abstract method that “reminds” the user that if they want to
create a Migration Class that inherits from here they should
implement a migrate method.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{islands}} \textendash{} list{[}SubPopulation{]}.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Nothing but raising an error.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.migration.random\_migration module}
\label{\detokenize{pygenalgo.operators.migration:module-pygenalgo.operators.migration.random_migration}}\label{\detokenize{pygenalgo.operators.migration:pygenalgo-operators-migration-random-migration-module}}\index{module@\spxentry{module}!pygenalgo.operators.migration.random\_migration@\spxentry{pygenalgo.operators.migration.random\_migration}}\index{pygenalgo.operators.migration.random\_migration@\spxentry{pygenalgo.operators.migration.random\_migration}!module@\spxentry{module}}\index{RandomMigration (class in pygenalgo.operators.migration.random\_migration)@\spxentry{RandomMigration}\spxextra{class in pygenalgo.operators.migration.random\_migration}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.migration:pygenalgo.operators.migration.random_migration.RandomMigration}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.migration.random\_migration.}}\sphinxbfcode{\sphinxupquote{RandomMigration}}}{\sphinxparam{\DUrole{n}{migration\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.95}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.migration:pygenalgo.operators.migration.migration_operator.MigrationOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MigrationOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Random Migration implements a “very basic” migration policy in which
each island migrates its best chromosome to a randomly selected population.
\end{quote}
\index{migrate() (pygenalgo.operators.migration.random\_migration.RandomMigration method)@\spxentry{migrate()}\spxextra{pygenalgo.operators.migration.random\_migration.RandomMigration method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.migration:pygenalgo.operators.migration.random_migration.RandomMigration.migrate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{migrate}}}{\sphinxparam{\DUrole{n}{islands}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.engines:pygenalgo.engines.auxiliary.SubPopulation}]{\sphinxcrossref{SubPopulation}}}\DUrole{p}{{]}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Perform the migration operation on the list of SubPopulations.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{islands}} \textendash{} list{[}SubPopulation{]}.

\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{Module contents}
\label{\detokenize{pygenalgo.operators.migration:module-pygenalgo.operators.migration}}\label{\detokenize{pygenalgo.operators.migration:module-contents}}\index{module@\spxentry{module}!pygenalgo.operators.migration@\spxentry{pygenalgo.operators.migration}}\index{pygenalgo.operators.migration@\spxentry{pygenalgo.operators.migration}!module@\spxentry{module}}
\sphinxstepscope


\subparagraph{pygenalgo.operators.mutation package}
\label{\detokenize{pygenalgo.operators.mutation:pygenalgo-operators-mutation-package}}\label{\detokenize{pygenalgo.operators.mutation::doc}}

\subparagraph{Submodules}
\label{\detokenize{pygenalgo.operators.mutation:submodules}}

\subparagraph{pygenalgo.operators.mutation.flip\_mutator module}
\label{\detokenize{pygenalgo.operators.mutation:module-pygenalgo.operators.mutation.flip_mutator}}\label{\detokenize{pygenalgo.operators.mutation:pygenalgo-operators-mutation-flip-mutator-module}}\index{module@\spxentry{module}!pygenalgo.operators.mutation.flip\_mutator@\spxentry{pygenalgo.operators.mutation.flip\_mutator}}\index{pygenalgo.operators.mutation.flip\_mutator@\spxentry{pygenalgo.operators.mutation.flip\_mutator}!module@\spxentry{module}}\index{FlipMutator (class in pygenalgo.operators.mutation.flip\_mutator)@\spxentry{FlipMutator}\spxextra{class in pygenalgo.operators.mutation.flip\_mutator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.flip_mutator.FlipMutator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.mutation.flip\_mutator.}}\sphinxbfcode{\sphinxupquote{FlipMutator}}}{\sphinxparam{\DUrole{n}{mutate\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.mutate_operator.MutationOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MutationOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Flip mutator, mutates the chromosome by selecting randomly
a position and flip its Gene value (0 \sphinxhyphen{}\textgreater{} 1, or 1 \sphinxhyphen{}\textgreater{} 0).
\end{quote}
\index{mutate() (pygenalgo.operators.mutation.flip\_mutator.FlipMutator method)@\spxentry{mutate()}\spxextra{pygenalgo.operators.mutation.flip\_mutator.FlipMutator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.flip_mutator.FlipMutator.mutate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate}}}{\sphinxparam{\DUrole{n}{individual}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Perform the mutation operation by randomly flipping a gene.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{individual}} \textendash{} (Chromosome).

\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.mutation.gaussian\_mutator module}
\label{\detokenize{pygenalgo.operators.mutation:module-pygenalgo.operators.mutation.gaussian_mutator}}\label{\detokenize{pygenalgo.operators.mutation:pygenalgo-operators-mutation-gaussian-mutator-module}}\index{module@\spxentry{module}!pygenalgo.operators.mutation.gaussian\_mutator@\spxentry{pygenalgo.operators.mutation.gaussian\_mutator}}\index{pygenalgo.operators.mutation.gaussian\_mutator@\spxentry{pygenalgo.operators.mutation.gaussian\_mutator}!module@\spxentry{module}}\index{GaussianMutator (class in pygenalgo.operators.mutation.gaussian\_mutator)@\spxentry{GaussianMutator}\spxextra{class in pygenalgo.operators.mutation.gaussian\_mutator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.gaussian_mutator.GaussianMutator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.mutation.gaussian\_mutator.}}\sphinxbfcode{\sphinxupquote{GaussianMutator}}}{\sphinxparam{\DUrole{n}{mutate\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.mutate_operator.MutationOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MutationOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Gaussian mutator, mutates the chromosome by selecting randomly a position
and add a Gaussian random value to the current gene value.
\end{quote}
\index{mutate() (pygenalgo.operators.mutation.gaussian\_mutator.GaussianMutator method)@\spxentry{mutate()}\spxextra{pygenalgo.operators.mutation.gaussian\_mutator.GaussianMutator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.gaussian_mutator.GaussianMutator.mutate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate}}}{\sphinxparam{\DUrole{n}{individual}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Perform the mutation operation by randomly adding the
Gaussian value to a randomly selected gene position.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{individual}} \textendash{} (Chromosome).

\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.mutation.inverse\_mutator module}
\label{\detokenize{pygenalgo.operators.mutation:module-pygenalgo.operators.mutation.inverse_mutator}}\label{\detokenize{pygenalgo.operators.mutation:pygenalgo-operators-mutation-inverse-mutator-module}}\index{module@\spxentry{module}!pygenalgo.operators.mutation.inverse\_mutator@\spxentry{pygenalgo.operators.mutation.inverse\_mutator}}\index{pygenalgo.operators.mutation.inverse\_mutator@\spxentry{pygenalgo.operators.mutation.inverse\_mutator}!module@\spxentry{module}}\index{InverseMutator (class in pygenalgo.operators.mutation.inverse\_mutator)@\spxentry{InverseMutator}\spxextra{class in pygenalgo.operators.mutation.inverse\_mutator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.inverse_mutator.InverseMutator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.mutation.inverse\_mutator.}}\sphinxbfcode{\sphinxupquote{InverseMutator}}}{\sphinxparam{\DUrole{n}{mutate\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.mutate_operator.MutationOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MutationOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Inverse mutator mutates the chromosome by inverting the order of
the gene values between two randomly selected gene end\sphinxhyphen{}positions.
\end{quote}
\index{mutate() (pygenalgo.operators.mutation.inverse\_mutator.InverseMutator method)@\spxentry{mutate()}\spxextra{pygenalgo.operators.mutation.inverse\_mutator.InverseMutator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.inverse_mutator.InverseMutator.mutate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate}}}{\sphinxparam{\DUrole{n}{individual}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Perform the mutation operation by inverting the genes
between at two random positions.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{individual}} \textendash{} (Chromosome).

\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.mutation.meta\_mutator module}
\label{\detokenize{pygenalgo.operators.mutation:module-pygenalgo.operators.mutation.meta_mutator}}\label{\detokenize{pygenalgo.operators.mutation:pygenalgo-operators-mutation-meta-mutator-module}}\index{module@\spxentry{module}!pygenalgo.operators.mutation.meta\_mutator@\spxentry{pygenalgo.operators.mutation.meta\_mutator}}\index{pygenalgo.operators.mutation.meta\_mutator@\spxentry{pygenalgo.operators.mutation.meta\_mutator}!module@\spxentry{module}}\index{MetaMutator (class in pygenalgo.operators.mutation.meta\_mutator)@\spxentry{MetaMutator}\spxextra{class in pygenalgo.operators.mutation.meta\_mutator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.meta_mutator.MetaMutator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.mutation.meta\_mutator.}}\sphinxbfcode{\sphinxupquote{MetaMutator}}}{\sphinxparam{\DUrole{n}{mutate\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.mutate_operator.MutationOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MutationOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Meta\sphinxhyphen{}mutator, mutates the chromosome by applying randomly
all other mutators (one at a time), with equal probability.

\sphinxAtStartPar
NOTE: In the future the equal probabilities can be amended.
\end{quote}
\index{all\_counters (pygenalgo.operators.mutation.meta\_mutator.MetaMutator property)@\spxentry{all\_counters}\spxextra{pygenalgo.operators.mutation.meta\_mutator.MetaMutator property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.meta_mutator.MetaMutator.all_counters}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{all\_counters}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }dict}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor (getter) of the application counter from all the internal mutators.
This is mostly to verify that everything is working as expected.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
a dictionary with the counter calls for all mutator methods.

\end{description}\end{quote}

\end{fulllineitems}

\index{mutate() (pygenalgo.operators.mutation.meta\_mutator.MetaMutator method)@\spxentry{mutate()}\spxextra{pygenalgo.operators.mutation.meta\_mutator.MetaMutator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.meta_mutator.MetaMutator.mutate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate}}}{\sphinxparam{\DUrole{n}{individual}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Perform the mutation operation by randomly applying another mutator.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{individual}} \textendash{} (Chromosome).

\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{reset\_counter() (pygenalgo.operators.mutation.meta\_mutator.MetaMutator method)@\spxentry{reset\_counter()}\spxextra{pygenalgo.operators.mutation.meta\_mutator.MetaMutator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.meta_mutator.MetaMutator.reset_counter}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset\_counter}}}{}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Sets ALL the counters to ‘zero’. We have to override the super().reset\_counter()
method, because we have to call explicitly the reset\_counter on all the internal
operators.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.mutation.mutate\_operator module}
\label{\detokenize{pygenalgo.operators.mutation:module-pygenalgo.operators.mutation.mutate_operator}}\label{\detokenize{pygenalgo.operators.mutation:pygenalgo-operators-mutation-mutate-operator-module}}\index{module@\spxentry{module}!pygenalgo.operators.mutation.mutate\_operator@\spxentry{pygenalgo.operators.mutation.mutate\_operator}}\index{pygenalgo.operators.mutation.mutate\_operator@\spxentry{pygenalgo.operators.mutation.mutate\_operator}!module@\spxentry{module}}\index{MutationOperator (class in pygenalgo.operators.mutation.mutate\_operator)@\spxentry{MutationOperator}\spxextra{class in pygenalgo.operators.mutation.mutate\_operator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.mutate_operator.MutationOperator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.mutation.mutate\_operator.}}\sphinxbfcode{\sphinxupquote{MutationOperator}}}{\sphinxparam{\DUrole{n}{mutation\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators:pygenalgo.operators.genetic_operator.GeneticOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GeneticOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Provides the base class (interface) for a Mutation Operator.
\end{quote}
\index{mutate() (pygenalgo.operators.mutation.mutate\_operator.MutationOperator method)@\spxentry{mutate()}\spxextra{pygenalgo.operators.mutation.mutate\_operator.MutationOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.mutate_operator.MutationOperator.mutate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate}}}{\sphinxparam{\DUrole{n}{individual}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Abstract method that “reminds” the user that if they want to
create a Mutation Class that inherits from here they should
implement a mutate method.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{individual}} \textendash{} the chromosome to be mutated.

\sphinxlineitem{Returns}
\sphinxAtStartPar
Nothing but raising an error.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.mutation.random\_mutator module}
\label{\detokenize{pygenalgo.operators.mutation:module-pygenalgo.operators.mutation.random_mutator}}\label{\detokenize{pygenalgo.operators.mutation:pygenalgo-operators-mutation-random-mutator-module}}\index{module@\spxentry{module}!pygenalgo.operators.mutation.random\_mutator@\spxentry{pygenalgo.operators.mutation.random\_mutator}}\index{pygenalgo.operators.mutation.random\_mutator@\spxentry{pygenalgo.operators.mutation.random\_mutator}!module@\spxentry{module}}\index{RandomMutator (class in pygenalgo.operators.mutation.random\_mutator)@\spxentry{RandomMutator}\spxextra{class in pygenalgo.operators.mutation.random\_mutator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.random_mutator.RandomMutator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.mutation.random\_mutator.}}\sphinxbfcode{\sphinxupquote{RandomMutator}}}{\sphinxparam{\DUrole{n}{mutate\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.mutate_operator.MutationOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MutationOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Random mutator, mutates the chromosome by selecting randomly a position and replace
the Gene with a new one that has been generated randomly (uniform probability).
\end{quote}
\index{mutate() (pygenalgo.operators.mutation.random\_mutator.RandomMutator method)@\spxentry{mutate()}\spxextra{pygenalgo.operators.mutation.random\_mutator.RandomMutator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.random_mutator.RandomMutator.mutate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate}}}{\sphinxparam{\DUrole{n}{individual}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Perform the mutation operation by randomly replacing a gene
with a new one that has been generated randomly.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{individual}} \textendash{} (Chromosome).

\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.mutation.shuffle\_mutator module}
\label{\detokenize{pygenalgo.operators.mutation:module-pygenalgo.operators.mutation.shuffle_mutator}}\label{\detokenize{pygenalgo.operators.mutation:pygenalgo-operators-mutation-shuffle-mutator-module}}\index{module@\spxentry{module}!pygenalgo.operators.mutation.shuffle\_mutator@\spxentry{pygenalgo.operators.mutation.shuffle\_mutator}}\index{pygenalgo.operators.mutation.shuffle\_mutator@\spxentry{pygenalgo.operators.mutation.shuffle\_mutator}!module@\spxentry{module}}\index{ShuffleMutator (class in pygenalgo.operators.mutation.shuffle\_mutator)@\spxentry{ShuffleMutator}\spxextra{class in pygenalgo.operators.mutation.shuffle\_mutator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.shuffle_mutator.ShuffleMutator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.mutation.shuffle\_mutator.}}\sphinxbfcode{\sphinxupquote{ShuffleMutator}}}{\sphinxparam{\DUrole{n}{mutate\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.mutate_operator.MutationOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MutationOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Shuffle mutator mutates the chromosome by shuffling the gene
values between two randomly selected gene end\sphinxhyphen{}positions.
\end{quote}
\index{mutate() (pygenalgo.operators.mutation.shuffle\_mutator.ShuffleMutator method)@\spxentry{mutate()}\spxextra{pygenalgo.operators.mutation.shuffle\_mutator.ShuffleMutator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.shuffle_mutator.ShuffleMutator.mutate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate}}}{\sphinxparam{\DUrole{n}{individual}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Perform the mutation operation by shuffling the genes
between at two random positions.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{individual}} \textendash{} (Chromosome).

\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.mutation.swap\_mutator module}
\label{\detokenize{pygenalgo.operators.mutation:module-pygenalgo.operators.mutation.swap_mutator}}\label{\detokenize{pygenalgo.operators.mutation:pygenalgo-operators-mutation-swap-mutator-module}}\index{module@\spxentry{module}!pygenalgo.operators.mutation.swap\_mutator@\spxentry{pygenalgo.operators.mutation.swap\_mutator}}\index{pygenalgo.operators.mutation.swap\_mutator@\spxentry{pygenalgo.operators.mutation.swap\_mutator}!module@\spxentry{module}}\index{SwapMutator (class in pygenalgo.operators.mutation.swap\_mutator)@\spxentry{SwapMutator}\spxextra{class in pygenalgo.operators.mutation.swap\_mutator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.swap_mutator.SwapMutator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.mutation.swap\_mutator.}}\sphinxbfcode{\sphinxupquote{SwapMutator}}}{\sphinxparam{\DUrole{n}{mutate\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.mutate_operator.MutationOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MutationOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Swap mutator mutates the chromosome by swapping the gene
values between two randomly selected gene positions.
\end{quote}
\index{mutate() (pygenalgo.operators.mutation.swap\_mutator.SwapMutator method)@\spxentry{mutate()}\spxextra{pygenalgo.operators.mutation.swap\_mutator.SwapMutator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.mutation:pygenalgo.operators.mutation.swap_mutator.SwapMutator.mutate}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mutate}}}{\sphinxparam{\DUrole{n}{individual}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Perform the mutation operation by swapping the genes at two random positions.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{individual}} \textendash{} (Chromosome).

\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{Module contents}
\label{\detokenize{pygenalgo.operators.mutation:module-pygenalgo.operators.mutation}}\label{\detokenize{pygenalgo.operators.mutation:module-contents}}\index{module@\spxentry{module}!pygenalgo.operators.mutation@\spxentry{pygenalgo.operators.mutation}}\index{pygenalgo.operators.mutation@\spxentry{pygenalgo.operators.mutation}!module@\spxentry{module}}
\sphinxstepscope


\subparagraph{pygenalgo.operators.selection package}
\label{\detokenize{pygenalgo.operators.selection:pygenalgo-operators-selection-package}}\label{\detokenize{pygenalgo.operators.selection::doc}}

\subparagraph{Submodules}
\label{\detokenize{pygenalgo.operators.selection:submodules}}

\subparagraph{pygenalgo.operators.selection.boltzmann\_selector module}
\label{\detokenize{pygenalgo.operators.selection:module-pygenalgo.operators.selection.boltzmann_selector}}\label{\detokenize{pygenalgo.operators.selection:pygenalgo-operators-selection-boltzmann-selector-module}}\index{module@\spxentry{module}!pygenalgo.operators.selection.boltzmann\_selector@\spxentry{pygenalgo.operators.selection.boltzmann\_selector}}\index{pygenalgo.operators.selection.boltzmann\_selector@\spxentry{pygenalgo.operators.selection.boltzmann\_selector}!module@\spxentry{module}}\index{BoltzmannSelector (class in pygenalgo.operators.selection.boltzmann\_selector)@\spxentry{BoltzmannSelector}\spxextra{class in pygenalgo.operators.selection.boltzmann\_selector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.boltzmann_selector.BoltzmannSelector}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.selection.boltzmann\_selector.}}\sphinxbfcode{\sphinxupquote{BoltzmannSelector}}}{\sphinxparam{\DUrole{n}{select\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{k}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{100.0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.select_operator.SelectionOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SelectionOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Boltzmann Selector implements an object that performs selection by choosing an individual
from a set of individuals by sampling solutions from a Boltzmann distribution depending on
their fitness’s.
\end{quote}
\index{select() (pygenalgo.operators.selection.boltzmann\_selector.BoltzmannSelector method)@\spxentry{select()}\spxextra{pygenalgo.operators.selection.boltzmann\_selector.BoltzmannSelector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.boltzmann_selector.BoltzmannSelector.select}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{select}}}{\sphinxparam{\DUrole{n}{population}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}\DUrole{p}{{]}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Select the individuals, from the input population, that will be passed on to the next
genetic operations of crossover and mutation to form the new population of solutions.

\sphinxAtStartPar
NOTE: the Boltzmann constant is held in the ‘\_items’ variable.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{population}} \textendash{} a list of chromosomes to select the parents from.

\sphinxlineitem{Returns}
\sphinxAtStartPar
the selected parents population (as list of chromosomes).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.selection.linear\_rank\_selector module}
\label{\detokenize{pygenalgo.operators.selection:module-pygenalgo.operators.selection.linear_rank_selector}}\label{\detokenize{pygenalgo.operators.selection:pygenalgo-operators-selection-linear-rank-selector-module}}\index{module@\spxentry{module}!pygenalgo.operators.selection.linear\_rank\_selector@\spxentry{pygenalgo.operators.selection.linear\_rank\_selector}}\index{pygenalgo.operators.selection.linear\_rank\_selector@\spxentry{pygenalgo.operators.selection.linear\_rank\_selector}!module@\spxentry{module}}\index{LinearRankSelector (class in pygenalgo.operators.selection.linear\_rank\_selector)@\spxentry{LinearRankSelector}\spxextra{class in pygenalgo.operators.selection.linear\_rank\_selector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.linear_rank_selector.LinearRankSelector}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.selection.linear\_rank\_selector.}}\sphinxbfcode{\sphinxupquote{LinearRankSelector}}}{\sphinxparam{\DUrole{n}{select\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1.0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.select_operator.SelectionOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SelectionOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Linear Rank Selector implements an object that performs selection using ranking.
The individuals first are sorted according to their fitness values. The rank N
is assigned to the best individual and the rank 1 to the worst individual.

\sphinxAtStartPar
After that the selection process is similar to the one of RouletteWheelSelector.
\end{quote}
\index{select() (pygenalgo.operators.selection.linear\_rank\_selector.LinearRankSelector method)@\spxentry{select()}\spxextra{pygenalgo.operators.selection.linear\_rank\_selector.LinearRankSelector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.linear_rank_selector.LinearRankSelector.select}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{select}}}{\sphinxparam{\DUrole{n}{population}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}\DUrole{p}{{]}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Select the individuals, from the input population, that will be passed on to the next
genetic operations of crossover and mutation to form the new population of solutions.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{population}} \textendash{} a list of chromosomes to select the parents from.

\sphinxlineitem{Returns}
\sphinxAtStartPar
the selected parents population (as list of chromosomes).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.selection.random\_selector module}
\label{\detokenize{pygenalgo.operators.selection:module-pygenalgo.operators.selection.random_selector}}\label{\detokenize{pygenalgo.operators.selection:pygenalgo-operators-selection-random-selector-module}}\index{module@\spxentry{module}!pygenalgo.operators.selection.random\_selector@\spxentry{pygenalgo.operators.selection.random\_selector}}\index{pygenalgo.operators.selection.random\_selector@\spxentry{pygenalgo.operators.selection.random\_selector}!module@\spxentry{module}}\index{RandomSelector (class in pygenalgo.operators.selection.random\_selector)@\spxentry{RandomSelector}\spxextra{class in pygenalgo.operators.selection.random\_selector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.random_selector.RandomSelector}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.selection.random\_selector.}}\sphinxbfcode{\sphinxupquote{RandomSelector}}}{\sphinxparam{\DUrole{n}{select\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1.0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.select_operator.SelectionOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SelectionOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Random Selector implements selection assuming that all members of the population have the
same probability to be selected as parents 1/N, effectively assuming a uniform probability.

\sphinxAtStartPar
It does not favour the fit individuals therefore the mixing will be very slow.
\end{quote}
\index{select() (pygenalgo.operators.selection.random\_selector.RandomSelector method)@\spxentry{select()}\spxextra{pygenalgo.operators.selection.random\_selector.RandomSelector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.random_selector.RandomSelector.select}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{select}}}{\sphinxparam{\DUrole{n}{population}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}\DUrole{p}{{]}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Select the individuals, from the input population, that will be passed on to the next
genetic operations of crossover and mutation to form the new population of solutions.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{population}} \textendash{} a list of chromosomes to select the parents from.

\sphinxlineitem{Returns}
\sphinxAtStartPar
the selected parents population (as list of chromosomes).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.selection.roulette\_wheel\_selector module}
\label{\detokenize{pygenalgo.operators.selection:module-pygenalgo.operators.selection.roulette_wheel_selector}}\label{\detokenize{pygenalgo.operators.selection:pygenalgo-operators-selection-roulette-wheel-selector-module}}\index{module@\spxentry{module}!pygenalgo.operators.selection.roulette\_wheel\_selector@\spxentry{pygenalgo.operators.selection.roulette\_wheel\_selector}}\index{pygenalgo.operators.selection.roulette\_wheel\_selector@\spxentry{pygenalgo.operators.selection.roulette\_wheel\_selector}!module@\spxentry{module}}\index{RouletteWheelSelector (class in pygenalgo.operators.selection.roulette\_wheel\_selector)@\spxentry{RouletteWheelSelector}\spxextra{class in pygenalgo.operators.selection.roulette\_wheel\_selector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.roulette_wheel_selector.RouletteWheelSelector}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.selection.roulette\_wheel\_selector.}}\sphinxbfcode{\sphinxupquote{RouletteWheelSelector}}}{\sphinxparam{\DUrole{n}{select\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1.0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.select_operator.SelectionOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SelectionOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Roulette Wheel Selector implements ‘fitness proportional selection’. Each member of the population
is assigned a probability value that is directly proportional to its fitness value (compared to the
rest of the population).

\sphinxAtStartPar
Individuals with higher fitness value are more likely to be selected for parents when forming the
new generation of individuals (offsprings).
\end{quote}
\index{select() (pygenalgo.operators.selection.roulette\_wheel\_selector.RouletteWheelSelector method)@\spxentry{select()}\spxextra{pygenalgo.operators.selection.roulette\_wheel\_selector.RouletteWheelSelector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.roulette_wheel_selector.RouletteWheelSelector.select}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{select}}}{\sphinxparam{\DUrole{n}{population}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}\DUrole{p}{{]}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Select the individuals, from the input population, that will be passed on to the next
genetic operations of crossover and mutation to form the new population of solutions.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{population}} \textendash{} a list of chromosomes to select the parents from.

\sphinxlineitem{Returns}
\sphinxAtStartPar
the selected parents population (as list of chromosomes).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.selection.select\_operator module}
\label{\detokenize{pygenalgo.operators.selection:module-pygenalgo.operators.selection.select_operator}}\label{\detokenize{pygenalgo.operators.selection:pygenalgo-operators-selection-select-operator-module}}\index{module@\spxentry{module}!pygenalgo.operators.selection.select\_operator@\spxentry{pygenalgo.operators.selection.select\_operator}}\index{pygenalgo.operators.selection.select\_operator@\spxentry{pygenalgo.operators.selection.select\_operator}!module@\spxentry{module}}\index{SelectionOperator (class in pygenalgo.operators.selection.select\_operator)@\spxentry{SelectionOperator}\spxextra{class in pygenalgo.operators.selection.select\_operator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.select_operator.SelectionOperator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.selection.select\_operator.}}\sphinxbfcode{\sphinxupquote{SelectionOperator}}}{\sphinxparam{\DUrole{n}{selection\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators:pygenalgo.operators.genetic_operator.GeneticOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GeneticOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Provides the base class (interface) for a Selection Operator.  Note that even
though the operator accepts a probability value, for the moment this operator
is applied with 100\% probability.
\end{quote}
\index{select() (pygenalgo.operators.selection.select\_operator.SelectionOperator method)@\spxentry{select()}\spxextra{pygenalgo.operators.selection.select\_operator.SelectionOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.select_operator.SelectionOperator.select}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{select}}}{\sphinxparam{\DUrole{n}{population}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}\DUrole{p}{{]}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Abstract method that “reminds” the user that if they want to
create a Selection Class that inherits from here they should
implement a select method.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{population}} \textendash{} is a list, with the chromosomes, to select

\end{description}\end{quote}

\sphinxAtStartPar
the parents for the next generation
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Nothing but raising an error.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.selection.stochastic\_universal\_selector module}
\label{\detokenize{pygenalgo.operators.selection:module-pygenalgo.operators.selection.stochastic_universal_selector}}\label{\detokenize{pygenalgo.operators.selection:pygenalgo-operators-selection-stochastic-universal-selector-module}}\index{module@\spxentry{module}!pygenalgo.operators.selection.stochastic\_universal\_selector@\spxentry{pygenalgo.operators.selection.stochastic\_universal\_selector}}\index{pygenalgo.operators.selection.stochastic\_universal\_selector@\spxentry{pygenalgo.operators.selection.stochastic\_universal\_selector}!module@\spxentry{module}}\index{StochasticUniversalSelector (class in pygenalgo.operators.selection.stochastic\_universal\_selector)@\spxentry{StochasticUniversalSelector}\spxextra{class in pygenalgo.operators.selection.stochastic\_universal\_selector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.stochastic_universal_selector.StochasticUniversalSelector}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.selection.stochastic\_universal\_selector.}}\sphinxbfcode{\sphinxupquote{StochasticUniversalSelector}}}{\sphinxparam{\DUrole{n}{select\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1.0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.select_operator.SelectionOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SelectionOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Stochastic Universal Selector is an extension of fitness proportionate selection (i.e. RouletteWheelSelection)
which exhibits no bias and minimal spread. Where RWS chooses several solutions from the population by repeated
random sampling, SUS uses a single random value to sample all the solutions by choosing them at evenly spaced
intervals. This gives weaker members of the population (according to their fitness) a chance to be chosen.
\end{quote}
\index{select() (pygenalgo.operators.selection.stochastic\_universal\_selector.StochasticUniversalSelector method)@\spxentry{select()}\spxextra{pygenalgo.operators.selection.stochastic\_universal\_selector.StochasticUniversalSelector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.stochastic_universal_selector.StochasticUniversalSelector.select}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{select}}}{\sphinxparam{\DUrole{n}{population}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}\DUrole{p}{{]}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Select the individuals, from the input population, that will be passed on to the next
genetic operations of crossover and mutation to form the new population of solutions.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{population}} \textendash{} a list of chromosomes to select the parents from.

\sphinxlineitem{Returns}
\sphinxAtStartPar
the selected parents population (as list of chromosomes).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.selection.tournament\_selector module}
\label{\detokenize{pygenalgo.operators.selection:module-pygenalgo.operators.selection.tournament_selector}}\label{\detokenize{pygenalgo.operators.selection:pygenalgo-operators-selection-tournament-selector-module}}\index{module@\spxentry{module}!pygenalgo.operators.selection.tournament\_selector@\spxentry{pygenalgo.operators.selection.tournament\_selector}}\index{pygenalgo.operators.selection.tournament\_selector@\spxentry{pygenalgo.operators.selection.tournament\_selector}!module@\spxentry{module}}\index{TournamentSelector (class in pygenalgo.operators.selection.tournament\_selector)@\spxentry{TournamentSelector}\spxextra{class in pygenalgo.operators.selection.tournament\_selector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.tournament_selector.TournamentSelector}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.selection.tournament\_selector.}}\sphinxbfcode{\sphinxupquote{TournamentSelector}}}{\sphinxparam{\DUrole{n}{select\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{k}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{int}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{5}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.select_operator.SelectionOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SelectionOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Tournament Selector implements an object that performs selection by choosing
an individual from a set of individuals. The winner of each tournament i.e.
(the one with the highest fitness value) is selected as new parent to perform
crossover and mutation.
\end{quote}
\index{select() (pygenalgo.operators.selection.tournament\_selector.TournamentSelector method)@\spxentry{select()}\spxextra{pygenalgo.operators.selection.tournament\_selector.TournamentSelector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.tournament_selector.TournamentSelector.select}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{select}}}{\sphinxparam{\DUrole{n}{population}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}\DUrole{p}{{]}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Select the individuals, from the input population, that will be passed on to the next
genetic operations of crossover and mutation to form the new population of solutions.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{population}} \textendash{} a list of chromosomes to select the parents from.

\sphinxlineitem{Returns}
\sphinxAtStartPar
the selected parents population (as list of chromosomes).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{pygenalgo.operators.selection.truncation\_selector module}
\label{\detokenize{pygenalgo.operators.selection:module-pygenalgo.operators.selection.truncation_selector}}\label{\detokenize{pygenalgo.operators.selection:pygenalgo-operators-selection-truncation-selector-module}}\index{module@\spxentry{module}!pygenalgo.operators.selection.truncation\_selector@\spxentry{pygenalgo.operators.selection.truncation\_selector}}\index{pygenalgo.operators.selection.truncation\_selector@\spxentry{pygenalgo.operators.selection.truncation\_selector}!module@\spxentry{module}}\index{TruncationSelector (class in pygenalgo.operators.selection.truncation\_selector)@\spxentry{TruncationSelector}\spxextra{class in pygenalgo.operators.selection.truncation\_selector}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.truncation_selector.TruncationSelector}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.selection.truncation\_selector.}}\sphinxbfcode{\sphinxupquote{TruncationSelector}}}{\sphinxparam{\DUrole{n}{select\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{1.0}}\sphinxparamcomma \sphinxparam{\DUrole{n}{p}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}\DUrole{w}{ }\DUrole{o}{=}\DUrole{w}{ }\DUrole{default_value}{0.3}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.select_operator.SelectionOperator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{SelectionOperator}}}}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Truncation Selector, creates a new population using a pre\sphinxhyphen{}defined proportion of the old population.
When this method is called, it sorts the individuals of the OLD population using their fitness and
then using a predefined value (e.g. p=0.3 or 30\%) selects repeatedly new individuals from the top
0.3 percent of the old population, until we reach the required size of the NEW population.
\end{quote}
\index{select() (pygenalgo.operators.selection.truncation\_selector.TruncationSelector method)@\spxentry{select()}\spxextra{pygenalgo.operators.selection.truncation\_selector.TruncationSelector method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators.selection:pygenalgo.operators.selection.truncation_selector.TruncationSelector.select}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{select}}}{\sphinxparam{\DUrole{n}{population}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{list\DUrole{p}{{[}}{\hyperref[\detokenize{pygenalgo.genome:pygenalgo.genome.chromosome.Chromosome}]{\sphinxcrossref{Chromosome}}}\DUrole{p}{{]}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Select the individuals, from the input population, that will be passed on to the next
genetic operations of crossover and mutation to form the new population of solutions.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{population}} \textendash{} a list of chromosomes to select the parents from.

\sphinxlineitem{Returns}
\sphinxAtStartPar
the selected parents population (as list of chromosomes).

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subparagraph{Module contents}
\label{\detokenize{pygenalgo.operators.selection:module-pygenalgo.operators.selection}}\label{\detokenize{pygenalgo.operators.selection:module-contents}}\index{module@\spxentry{module}!pygenalgo.operators.selection@\spxentry{pygenalgo.operators.selection}}\index{pygenalgo.operators.selection@\spxentry{pygenalgo.operators.selection}!module@\spxentry{module}}

\paragraph{Submodules}
\label{\detokenize{pygenalgo.operators:submodules}}

\paragraph{pygenalgo.operators.genetic\_operator module}
\label{\detokenize{pygenalgo.operators:module-pygenalgo.operators.genetic_operator}}\label{\detokenize{pygenalgo.operators:pygenalgo-operators-genetic-operator-module}}\index{module@\spxentry{module}!pygenalgo.operators.genetic\_operator@\spxentry{pygenalgo.operators.genetic\_operator}}\index{pygenalgo.operators.genetic\_operator@\spxentry{pygenalgo.operators.genetic\_operator}!module@\spxentry{module}}\index{GeneticOperator (class in pygenalgo.operators.genetic\_operator)@\spxentry{GeneticOperator}\spxextra{class in pygenalgo.operators.genetic\_operator}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators:pygenalgo.operators.genetic_operator.GeneticOperator}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{pygenalgo.operators.genetic\_operator.}}\sphinxbfcode{\sphinxupquote{GeneticOperator}}}{\sphinxparam{\DUrole{n}{\_probability}\DUrole{p}{:}\DUrole{w}{ }\DUrole{n}{float}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Description:
\begin{quote}

\sphinxAtStartPar
Provides the base class (interface) for a Genetic Operator. This class includes some common
variables (such as the probability and the application counter) along with access to them.

\sphinxAtStartPar
All genetic operators (Selection, Crossover, Mutation, Migration) should inherit this class.
\end{quote}
\index{counter (pygenalgo.operators.genetic\_operator.GeneticOperator property)@\spxentry{counter}\spxextra{pygenalgo.operators.genetic\_operator.GeneticOperator property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators:pygenalgo.operators.genetic_operator.GeneticOperator.counter}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{counter}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }int}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor (getter) of the application counter.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the int value of the counter variable.

\end{description}\end{quote}

\end{fulllineitems}

\index{inc\_counter() (pygenalgo.operators.genetic\_operator.GeneticOperator method)@\spxentry{inc\_counter()}\spxextra{pygenalgo.operators.genetic\_operator.GeneticOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators:pygenalgo.operators.genetic_operator.GeneticOperator.inc_counter}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{inc\_counter}}}{}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Increase the counter value by one. This is applied
after each application of the genetic operator.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{items (pygenalgo.operators.genetic\_operator.GeneticOperator property)@\spxentry{items}\spxextra{pygenalgo.operators.genetic\_operator.GeneticOperator property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators:pygenalgo.operators.genetic_operator.GeneticOperator.items}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{items}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }list\DUrole{w}{ }\DUrole{p}{|}\DUrole{w}{ }tuple}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor (getter) of the \_items container.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
\_items (if any).

\end{description}\end{quote}

\end{fulllineitems}

\index{iter (pygenalgo.operators.genetic\_operator.GeneticOperator property)@\spxentry{iter}\spxextra{pygenalgo.operators.genetic\_operator.GeneticOperator property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators:pygenalgo.operators.genetic_operator.GeneticOperator.iter}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{iter}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }int}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor (getter) of the iteration parameter.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the iteration value.

\end{description}\end{quote}

\end{fulllineitems}

\index{probability (pygenalgo.operators.genetic\_operator.GeneticOperator property)@\spxentry{probability}\spxextra{pygenalgo.operators.genetic\_operator.GeneticOperator property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators:pygenalgo.operators.genetic_operator.GeneticOperator.probability}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{probability}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{ }float}}}
\pysigstopsignatures
\sphinxAtStartPar
Accessor (getter) of the probability.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the float value of the probability.

\end{description}\end{quote}

\end{fulllineitems}

\index{reset\_counter() (pygenalgo.operators.genetic\_operator.GeneticOperator method)@\spxentry{reset\_counter()}\spxextra{pygenalgo.operators.genetic\_operator.GeneticOperator method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators:pygenalgo.operators.genetic_operator.GeneticOperator.reset_counter}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reset\_counter}}}{}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Sets the counter value to zero.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
None.

\end{description}\end{quote}

\end{fulllineitems}

\index{rng (pygenalgo.operators.genetic\_operator.GeneticOperator property)@\spxentry{rng}\spxextra{pygenalgo.operators.genetic\_operator.GeneticOperator property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{pygenalgo.operators:pygenalgo.operators.genetic_operator.GeneticOperator.rng}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{ }}}\sphinxbfcode{\sphinxupquote{rng}}}
\pysigstopsignatures
\sphinxAtStartPar
Get access of the Class variable (\_rng).
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
the random number generator.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{Module contents}
\label{\detokenize{pygenalgo.operators:module-pygenalgo.operators}}\label{\detokenize{pygenalgo.operators:module-contents}}\index{module@\spxentry{module}!pygenalgo.operators@\spxentry{pygenalgo.operators}}\index{pygenalgo.operators@\spxentry{pygenalgo.operators}!module@\spxentry{module}}

\subsection{Module contents}
\label{\detokenize{pygenalgo:module-pygenalgo}}\label{\detokenize{pygenalgo:module-contents}}\index{module@\spxentry{module}!pygenalgo@\spxentry{pygenalgo}}\index{pygenalgo@\spxentry{pygenalgo}!module@\spxentry{module}}

\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{p}
\item\relax\sphinxstyleindexentry{pygenalgo}\sphinxstyleindexpageref{pygenalgo:\detokenize{module-pygenalgo}}
\item\relax\sphinxstyleindexentry{pygenalgo.engines}\sphinxstyleindexpageref{pygenalgo.engines:\detokenize{module-pygenalgo.engines}}
\item\relax\sphinxstyleindexentry{pygenalgo.engines.auxiliary}\sphinxstyleindexpageref{pygenalgo.engines:\detokenize{module-pygenalgo.engines.auxiliary}}
\item\relax\sphinxstyleindexentry{pygenalgo.engines.generic\_ga}\sphinxstyleindexpageref{pygenalgo.engines:\detokenize{module-pygenalgo.engines.generic_ga}}
\item\relax\sphinxstyleindexentry{pygenalgo.engines.island\_model\_ga}\sphinxstyleindexpageref{pygenalgo.engines:\detokenize{module-pygenalgo.engines.island_model_ga}}
\item\relax\sphinxstyleindexentry{pygenalgo.engines.standard\_ga}\sphinxstyleindexpageref{pygenalgo.engines:\detokenize{module-pygenalgo.engines.standard_ga}}
\item\relax\sphinxstyleindexentry{pygenalgo.genome}\sphinxstyleindexpageref{pygenalgo.genome:\detokenize{module-pygenalgo.genome}}
\item\relax\sphinxstyleindexentry{pygenalgo.genome.chromosome}\sphinxstyleindexpageref{pygenalgo.genome:\detokenize{module-pygenalgo.genome.chromosome}}
\item\relax\sphinxstyleindexentry{pygenalgo.genome.gene}\sphinxstyleindexpageref{pygenalgo.genome:\detokenize{module-pygenalgo.genome.gene}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators}\sphinxstyleindexpageref{pygenalgo.operators:\detokenize{module-pygenalgo.operators}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.crossover}\sphinxstyleindexpageref{pygenalgo.operators.crossover:\detokenize{module-pygenalgo.operators.crossover}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.crossover.crossover\_operator}\sphinxstyleindexpageref{pygenalgo.operators.crossover:\detokenize{module-pygenalgo.operators.crossover.crossover_operator}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.crossover.meta\_crossover}\sphinxstyleindexpageref{pygenalgo.operators.crossover:\detokenize{module-pygenalgo.operators.crossover.meta_crossover}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.crossover.mutli\_point\_crossover}\sphinxstyleindexpageref{pygenalgo.operators.crossover:\detokenize{module-pygenalgo.operators.crossover.mutli_point_crossover}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.crossover.order\_crossover}\sphinxstyleindexpageref{pygenalgo.operators.crossover:\detokenize{module-pygenalgo.operators.crossover.order_crossover}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.crossover.partially\_mapped\_crossover}\sphinxstyleindexpageref{pygenalgo.operators.crossover:\detokenize{module-pygenalgo.operators.crossover.partially_mapped_crossover}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.crossover.position\_based\_crossover}\sphinxstyleindexpageref{pygenalgo.operators.crossover:\detokenize{module-pygenalgo.operators.crossover.position_based_crossover}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.crossover.single\_point\_crossover}\sphinxstyleindexpageref{pygenalgo.operators.crossover:\detokenize{module-pygenalgo.operators.crossover.single_point_crossover}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.crossover.uniform\_crossover}\sphinxstyleindexpageref{pygenalgo.operators.crossover:\detokenize{module-pygenalgo.operators.crossover.uniform_crossover}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.genetic\_operator}\sphinxstyleindexpageref{pygenalgo.operators:\detokenize{module-pygenalgo.operators.genetic_operator}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.migration}\sphinxstyleindexpageref{pygenalgo.operators.migration:\detokenize{module-pygenalgo.operators.migration}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.migration.clockwise\_migration}\sphinxstyleindexpageref{pygenalgo.operators.migration:\detokenize{module-pygenalgo.operators.migration.clockwise_migration}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.migration.meta\_migration}\sphinxstyleindexpageref{pygenalgo.operators.migration:\detokenize{module-pygenalgo.operators.migration.meta_migration}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.migration.migration\_operator}\sphinxstyleindexpageref{pygenalgo.operators.migration:\detokenize{module-pygenalgo.operators.migration.migration_operator}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.migration.random\_migration}\sphinxstyleindexpageref{pygenalgo.operators.migration:\detokenize{module-pygenalgo.operators.migration.random_migration}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.mutation}\sphinxstyleindexpageref{pygenalgo.operators.mutation:\detokenize{module-pygenalgo.operators.mutation}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.mutation.flip\_mutator}\sphinxstyleindexpageref{pygenalgo.operators.mutation:\detokenize{module-pygenalgo.operators.mutation.flip_mutator}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.mutation.gaussian\_mutator}\sphinxstyleindexpageref{pygenalgo.operators.mutation:\detokenize{module-pygenalgo.operators.mutation.gaussian_mutator}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.mutation.inverse\_mutator}\sphinxstyleindexpageref{pygenalgo.operators.mutation:\detokenize{module-pygenalgo.operators.mutation.inverse_mutator}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.mutation.meta\_mutator}\sphinxstyleindexpageref{pygenalgo.operators.mutation:\detokenize{module-pygenalgo.operators.mutation.meta_mutator}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.mutation.mutate\_operator}\sphinxstyleindexpageref{pygenalgo.operators.mutation:\detokenize{module-pygenalgo.operators.mutation.mutate_operator}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.mutation.random\_mutator}\sphinxstyleindexpageref{pygenalgo.operators.mutation:\detokenize{module-pygenalgo.operators.mutation.random_mutator}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.mutation.shuffle\_mutator}\sphinxstyleindexpageref{pygenalgo.operators.mutation:\detokenize{module-pygenalgo.operators.mutation.shuffle_mutator}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.mutation.swap\_mutator}\sphinxstyleindexpageref{pygenalgo.operators.mutation:\detokenize{module-pygenalgo.operators.mutation.swap_mutator}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.selection}\sphinxstyleindexpageref{pygenalgo.operators.selection:\detokenize{module-pygenalgo.operators.selection}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.selection.boltzmann\_selector}\sphinxstyleindexpageref{pygenalgo.operators.selection:\detokenize{module-pygenalgo.operators.selection.boltzmann_selector}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.selection.linear\_rank\_selector}\sphinxstyleindexpageref{pygenalgo.operators.selection:\detokenize{module-pygenalgo.operators.selection.linear_rank_selector}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.selection.random\_selector}\sphinxstyleindexpageref{pygenalgo.operators.selection:\detokenize{module-pygenalgo.operators.selection.random_selector}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.selection.roulette\_wheel\_selector}\sphinxstyleindexpageref{pygenalgo.operators.selection:\detokenize{module-pygenalgo.operators.selection.roulette_wheel_selector}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.selection.select\_operator}\sphinxstyleindexpageref{pygenalgo.operators.selection:\detokenize{module-pygenalgo.operators.selection.select_operator}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.selection.stochastic\_universal\_selector}\sphinxstyleindexpageref{pygenalgo.operators.selection:\detokenize{module-pygenalgo.operators.selection.stochastic_universal_selector}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.selection.tournament\_selector}\sphinxstyleindexpageref{pygenalgo.operators.selection:\detokenize{module-pygenalgo.operators.selection.tournament_selector}}
\item\relax\sphinxstyleindexentry{pygenalgo.operators.selection.truncation\_selector}\sphinxstyleindexpageref{pygenalgo.operators.selection:\detokenize{module-pygenalgo.operators.selection.truncation_selector}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}